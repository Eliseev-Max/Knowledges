
Настройка iptables для Docker

Путь сетевого пакета до ядра Linux:
	Пакет → [PREROUTING.nat] → [INPUT.filter] → Kernel

Путь сетевого пакета до Docker:
	Пакет → [PREROUTING.nat] → [DOCKER.nat] → [FORWARD.filter] → *[DOCKER-USER.filter]* → [DOCKER-ISOLATION-STAGE-1.filter] → Docker
	
Для фильтрации трафика из внешней сети в Docker ► модифицировать таблицу DOCKER-USER

Настройки по умолчанию: таблица не задерживает пакеты, просто пропускает их дальше
	$ iptables -S DOCKER-USER
	-N DOCKER-USER					# создать цепочку
	-A DOCKER-USER -j RETURN		# добавить в цепочку правило: RETURN (прервать проверку по текущей цепочке)

Непосредственно настройка	
	$ sudo iptables -F DOCKER-USER					# очищаем таблицу
	$ sudo iptables -I DOCKER-USER -j REJECT		# запрещаем всё

Добавим ПЕРЕД запрещающими правилом разрешающие: 
	дадим доступ к [local-srv] из внутренней сети
		$ sudo iptables -I DOCKER-USER -o docker0 -s [ip_network/mask] -p tcp --dport 8123 -j RETURN
	
	дадим неограниченный доступ к процессу (сервису) на TCP-порту 6379:
		$ sudo iptables -I DOCKER-USER -o docker0 -p tcp --dport 6379 -j RETURN

<Разбор команд>:
	-I DOCKER-USER = вставить правило с нужным номером в цепочку DOCKER-USER
	-o docker0 = трафик, направленный на интерфейс docker0 (внутрь контейнера)
	-s [ip_network/mask] = (source) указываем IP-адрес устройства, на котором открываем доступ
	-p tcp = выбираем протокол транспортного уровня
	--dport = порт, прослушиваемый сервисом на хосте [ip_network/mask]

# пакеты из внешнего мира к контейнерам:  -i eno1 → FORWARD → -o docker0
# пояснение: <входной сетевой интерфейс eno1> → [Цепочка FORWARD для пересылаемых пакетов] → <'исходящий' сетевой интерфейс> 

# пакеты от докера в интернет:  -i docker0 → FORWARD → -o eno1

Настройка трафика из контейнера наружу
	$ iptables -A DOCKER-USER -i docker0 -j RETURN
	# "добавить правило в цепочку DOCKER-USER: к входящему сетевому интерфейсу docker0 применить действие RETURN"

Разрешаем ответы в соединениях, которые инициированы изнутри контейнера:
	$ iptables -A DOCKER-USER -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
	# пояснение:
Сопоставление conntrack — это расширенная версия сопоставления состояний, которая позволяет сопоставлять пакеты гораздо более детально.
Это позволяет вам просматривать информацию, непосредственно доступную в системе отслеживания соединений, без каких-либо «интерфейсных» систем,
("frontend" systems) таких как сопоставление состояний (state match).
Дополнительные сведения о системе отслеживания соединений см. в главе:
	https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#STATEMACHINE

В conntrack matches собрано несколько разных совпадений для нескольких разных полей в системе отслеживания соединений.
(см. Table 10-12. Conntrack match options)


---
Явные совпадения (explict matches)
https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MATCHES

Явные совпадения — это те, которые должны быть специально загружены с параметром -m или --match.
Совпадения состояний, например, требуют директивы -m state перед вводом фактического совпадения, которое вы хотите использовать.
Явные совпадения:
	• зависящие от протокола
	• не связанные с к.-л. протоколом (например, состояния подключения (connection states))

Типы подключений:
	• NEW, (новое) - первый пакет еще не установленного соединения
	• ESTABLISHED, (установленное)  - соединение, которое уже зарегистрировано в ядре
	• RELATED, (связанное) - новое соединение, созданное старым, установленным соединением
	• и т.д. (custom) - были разработаны для тестирования или экспериментальных целей, или просто для иллюстрации того, на что способен iptables

С каждым новым выпуском iptables появляются новые matches.

Разница между неявно загруженными (implicitly loaded) и явно загруженными (explicitly loaded) совпадениями
	♦ implicitly loaded matches будут загружаться автоматически, когда, например, вы сопоставляете свойства TCP-пакетов;
	♦ explicitly loaded matches никогда не будут загружаться автоматически,
								необходимо вручную обнаружить и активировать явные совпадения.

(ознакомиться с Table 10-6. Address types)

---
Понятие общих совпадений (generic matches)
	* общие совпадения можно использовать во всех правилах независимо от протокола;
	* помимо общих есть специализированные совпадения:
		• совпадения TCP - применяются только к TCP-пакетам;
		• совпадения UDP - применяются только к UDP-пакетам
		• совпадения ICMP - применяются только к ICMP-пакетам
		• специальные совпадения (совпадение состояния, владельца и ограничения и т.д.)
	* совпадение — это то, что указывает особое условие внутри пакета, которое должно быть истинным (или ложным)
	* одно правило может содержать несколько совпадений любого типа
		• например, пакеты, приходящие с определённого хоста LAN + на определённый порт
		• если хотя бы одно из всех совпадений fails → всё правило fails, проверяется следующее правило;
		• если все совпадения = true → применяется target, указанное в правиле.

Некоторые общие совпадения:
	-s, --src, --source
		- это сопоставление источника = сопоставление пакетов на основе их исходного IP-адреса.
		Можно использовать IP-адрес совместно с сетевой маской в бировой CIDR (/24) или обычной (255.255.255.0) форме.
		Можно инвертировать совпадение с помощью знака ! (--src ! 192.168.0.0/24 - все пакеты с исходным адресом, не входящим в диапазон)
	
	-d, --dst, --destination
		- это сопоставление используется для пакетов на основе их адреса или адресов назначения.
		Принцип действия и синтаксис такой же, как и у --source, НО сопоставление основано на том, куда направляются пакеты.
		Также возможна инверсия с помощью "!"
	
	-i, --in-interface
		это совпадение используется для интерфейса, на который пришел пакет.
		Опция допустима только в цепочках INPUT, FORWARD и PREROUTING (в любых других  → сообщение об ошибке)
		Поведение по умолчанию: если конкретный интерфейс не указан, строковое значение +
		Одиночный знак + (=сопоставление строки букв и цифр) указывает ядру, что нужно нужно сопоставлять все пакеты,
		независимо от того, через какой интерфейс они поступили.
		eth+ = все устройства Ethernet.
		Можно инвертировать значение этой опции с помощью "!"
		
	-o, --out-interface
		это совпадение используется для пакетов на интерфейсе, с которого они отправляются.
		Совпадение доступно только в цепочках OUTPUT, FORWARD и POSTROUTING.
		Принцип действия и синтаксис такой же, как и у -i.
	
---
Неявные совпадения (Implict matches)
	Implict matches загружаются неявно (автоматически).
	Три типа неявных совпадений:
		♦ TCP matches;
		♦ UDP matches;
		♦ ICMP matches.
	Неявным совпадениям не требуется опция -m (--match)
	
	--sport, --source-port
		сопоставление пакетов на основе исходного порта.
		Это сопоставление может принимать:
			• имя службы
				имя службы должно быть в файле /etc/services (iptables использует этот файл для поиска)
				
			• номер порта
				правило загрузится немного быстрее, т.к. iptables не нужно проверять имя сервиса.
				Поддерживает диапазоны портов
				  --source-port 22:80 == порты с 22 по 80
				  --source-port :80 == ports(0 - 80)
				  --source-port 22: == ports(22 - 65535)
			Поддерживает инверсию (!)
			Это сопоставление не обрабатывает несколько отдельных портов и диапазонов портов	
		
	--dport, --destination-port
		используется для сопоставления пакетов TCP в соответствии с их портом назначения.
		Синтаксис и принцип действия = --source-port
	
	