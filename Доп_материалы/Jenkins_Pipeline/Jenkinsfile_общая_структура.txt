# Плагины:
Multiselect parameter  -  работа с взаимосвязанными параметрами
Git parameter  -  выбор ветки репозиторий для сборки
Copy Artifact  -  копирование артефактов из другой сборки
Test Result Analyzer  -  анализ результатов тестов
Build Pipeline  -  удобное отображение upstream/downstream сборок
Git Changelog  -  отображение информации о коммите
Docker  -  Docker-контейнеры в качестве executors
Email Extension  -  гибкая настройка отправки email
Job Configuration History  -  изменения в настройках сборок


# Jenkinsfile (Declarative Pipeline)

# В синтаксисе декларативного пайплайна блок пайплайна определяет всю работу, выполняемую во всем пайплайне. 

pipeline {
    agent any 				# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stages {
        stage('Build') { 	# Определяет стадию "Build"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Build"
            }
        }
        stage('Test') { 	# Определяет стадию "Test"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Test"
            }
        }
        stage('Deploy') { 	# Определяет стадию "Deploy"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
            }
        }
    }
}


########################################################################################
########################################################################################
########################################################################################

# Jenkinsfile (Scripted Pipeline)

# В синтаксисе Scripted Pipeline один или несколько узловых блоков выполняют основную работу во всем пайплайне.
# Хотя это не является обязательным требованием синтаксиса Scripted Pipeline, ограничение работы вашего конвейера внутри блока узла делает две вещи:
#	1. Планирует выполнение шагов, содержащихся в блоке, путем добавления элемента в очередь Jenkins. 
# 	   Как только исполнитель освободится на узле, шаги будут запущены.
# 	2. Создает рабочую область (каталог, относящийся к конкретному конвейеру), где можно выполнять работу с файлами, извлеченными из системы управления версиями.
#      Предупреждение. В зависимости от конфигурации Jenkins некоторые рабочие области могут не очищаться автоматически после определенного периода бездействия. 

node {  					# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stage('Build') { 		# Определяет стадию "Build". Блоки stage являются необязательными в синтаксисе Scripted Pipeline. 
							# Однако реализация блоков этапов в Scripted Pipeline обеспечивает более четкую визуализацию подмножества
							# задач/шагов каждого этапа в пользовательском интерфейсе Jenkins.
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Build"
    }
    stage('Test') { 		# Определяет стадию "Test"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Test"
    }
    stage('Deploy') { 		# Определяет стадию "Deploy"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
    }
}


Пример:

#!groovy
//Check ub1 properties
properties([disableConcurrentBuilds()])		# Запретить параллельную сборку несколькими пользователями

pipeline {
	agent {
		label 'main'		# указываем, что собираем в ветке main
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: '2', artifactNumToKeepStr: '2'))
		timestamps()
	}
	stages {
		stage("Create docker image") {
			steps {
				echo " ========== start building image ========== "
				dir ('path/to/the/Dockerfile/in/repo') {
				sh 'docker build -t pipeline_tests . '
				}
			}
		}
	}
}


############################################################################
############################################################################
############################################################################
############################################################################

Как обсуждалось в разделе «Определение конвейера в SCM», Jenkinsfile — это текстовый файл, содержащий определение конвейера Jenkins и зарегистрированный в системе управления версиями. Рассмотрим следующий конвейер, который реализует базовый трехэтапный конвейер непрерывной доставки.

Не все пайплайны будут иметь эти три стадии, но это хорошая отправная точка для определения их для большинства проектов. В разделах ниже показано создание и выполнение простого конвейера в тестовой установке Jenkins.

Предполагается, что для проекта уже настроен репозиторий системы управления версиями, а конвейер определен в Jenkins в соответствии с этими инструкциями.

С помощью текстового редактора, в идеале поддерживающего подсветку синтаксиса Groovy, создайте новый Jenkinsfile в корневом каталоге проекта.

Приведенный выше пример декларативного конвейера содержит минимально необходимую структуру для реализации конвейера непрерывной доставки. Требуемая директива агента указывает Дженкинсу выделить исполнителя и рабочее пространство для конвейера. Без директивы агента декларативный конвейер не только недействителен, но и не способен выполнять какую-либо работу! По умолчанию директива агента гарантирует, что исходный репозиторий извлечен и доступен для шагов на последующих этапах.

Директива stage и директивы steps также необходимы для действительного декларативного конвейера, поскольку они указывают Jenkins, что выполнять и на каком этапе это должно быть выполнено.

Для более расширенного использования со Scripted Pipeline приведенный выше пример узла является важным первым шагом, поскольку он выделяет исполнителя и рабочее пространство для конвейера.


# Jenkinsfile (Scripted Pipeline)

node {						# выделяет исполнителя и рабочее пространство для конвейера;
							# без узла Pipeline не может выполнять никакой работы
    checkout scm 			# scm — это специальная переменная, которая указывает шагу проверки клонировать конкретную ревизию, которая инициировала этот запуск Pipeline 
    /* .. snip .. */
}

