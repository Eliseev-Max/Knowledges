# Плагины:
Multiselect parameter  -  работа с взаимосвязанными параметрами
Git parameter  -  выбор ветки репозиторий для сборки
Copy Artifact  -  копирование артефактов из другой сборки
Test Result Analyzer  -  анализ результатов тестов
Build Pipeline  -  удобное отображение upstream/downstream сборок
Git Changelog  -  отображение информации о коммите
Docker  -  Docker-контейнеры в качестве executors
Email Extension  -  гибкая настройка отправки email
Job Configuration History  -  изменения в настройках сборок


# Jenkinsfile (Declarative Pipeline)

# В синтаксисе декларативного пайплайна блок пайплайна определяет всю работу, выполняемую во всем пайплайне. 

pipeline {
    agent any 				# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stages {
        stage('Build') { 	# Определяет стадию "Build"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Build"
            }
        }
        stage('Test') { 	# Определяет стадию "Test"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Test"
            }
        }
        stage('Deploy') { 	# Определяет стадию "Deploy"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
            }
        }
    }
}

Декларативный pipeline - это относительно недавнее дополнение к Jenkins Pipeline, которое представляет более упрощенный и
самодостаточный синтаксис поверх подсистем pipeline.

Отличия Declarative Pipeline от синтаксиса Groovy:
	• верхний уровень Pipeline должен быть блоком, а именно: pipeline { };
    • точки с запятой не используются в качестве разделителей операторов, каждое выражение должно быть на отдельной строке;
    • блоки должны состоять только из разделов (Sections), директив (Directives), шагов (Steps) или операторов присваивания.
	• оператор ссылки на свойство рассматривается как вызов метода без аргументов. Так, например, ввод обрабатывается как input(). 

!!! В настоящее время существует нерешенная проблема, которая ОГРАНИЧИВАЕТ максимальный размер кода в блоке pipeline {}
	Это ограничение не распространяется на Scripted Pipeline 

Разделы (Sections):
	Разделы в Declarative Pipeline обычно содержат одну или более директиву (Directives) или шаг (Steps)

	agent
		
		Раздел agent указывает:
			► где будет выполняться весь pipeline, если расположен на самом верхнем уровне; ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ ЗАДАН
			► где будет выполняться определённый Stage, на уровне этапа (Stage)	-	НЕОБЯЗАТЕЛЬНО ЗАДАВАТЬ

		Различия между агентами высшего уровня (Top Level Agents) и агентами уровня этапа (Stage Agents)
		Top Level Agents:		
			параметры вызываются после входа в агент.
			Например, при использовании тайм-аута он будет применяться только к выполнению внутри агента

node("myAgent") {
    timeout(unit: 'SECONDS', time: 5) {
        stage("One"){
            sleep 10
            echo 'hello'
        }
    }
}

		Stage Agents
		параметры вызываются перед входом в агент и перед проверкой любых условий.
		В этом случае при использовании тайм-аута он применяется до выделения агента.
		
timeout(unit: 'SECONDS', time: 5) {
    stage("One"){
        node {
            sleep 10
            echo 'Hello'
        }
    }
}
	
		Этот тайм-аут будет включать время подготовки агента.
		Поскольку тайм-аут включает время подготовки агента, pipeline может дать сбой в тех случаях, когда выделение агента задерживается.
		
	Параметры
		Для поддержки широкого спектра вариантов использования, которые могут быть у авторов Pipeline,
		раздел агента поддерживает несколько различных типов параметров.
		Эти параметры могут применяться на верхнем уровне блока pipeline или внутри директивы каждого этапа. 
		
	• any
		выполняет Pipeline или этап на любом доступном агенте 
		pipeline {
			agent any
			...
		}
		
	• none
		при применении на верхнем уровне блока pipeline глобальный агент не будет выделен для всего запуска конвейера;
		каждый раздел этапа должен будет содержать свой собственный раздел агента
		pipeline {
			agent none
			...
		}
		
	• label
		выполненяет Pipeline или этап на агенте, доступном в окружении Jenkins с предоставленной меткой
		pipeline {
			agent agent { label 'my-defined-label' }
			...
		}
		
	• node
		agent { node { label 'labelName' } } 
			ведёт себя так же, как и 
		agent { label 'labelName' },
			но node позволяет использовать дополнительные параметры, такие как customWorkspace 
		
	• docker
		Выполняет Pipeline или этап с заданным контейнером, который будет динамически подготовлен на node,
		предварительно настроенном для приёма Pipelines на основе Docker или на node, соответствующем параметру метки.
		Docker также опционально может принимать параметр args, содержащий аргументы для непосредственной передачи
		в вызов docker run, и параметр alwaysPull, который принудительно выполнит команду docker pull,
		даже если имя образа уже существует.
		Пример:
			agent { docker 'maven:3.8.1-adoptopenjdk-11' }
			
			или
			
		agent {
    docker {
        image 'maven:3.8.1-adoptopenjdk-11'
        label 'my-defined-label'
        args  '-v /tmp:/tmp'
		}
	}	
	
	# !!! Имя параметра и его значение, взятое в " " или ' ' внутри директивы docker разделяются только пробелом!
	
	docker также дополнительно принимает параметры:
		♦ registryUrl,
		♦ registryCredentialsId,
	которые помогут указать используемый репозиторий Docker и его учетные данные.
	Параметр registryCredentialsId можно использовать отдельно для частных репозиториев в Docker Hub. Например: 
	
	agent {
    docker {
        image 'myregistry.com/node'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
		}
	}

	• dockerfile
		Выполняет Pipeline или этап с помощью контейнера, который собран из Dockerfile, содержащегося в исходном репозитории.
		Чтобы использовать этот параметр:
			► файл Jenkinsfile должен быть загружен либо из многоветвевого Pipeline, либо из конвейера из SCM.
		Обычно это Dockerfile в корне исходного репозитория:
		
[Jenkinsfile]:		agent { dockerfile true }

		Если Dockerfile содержится не в корневом, а в другом каталоге:
			► использовать параметр dir:

[Jenkinsfile]:		agent { dockerfile { dir 'someSubDir' } }

		Если файл Dockerfile имеет другое имя:
			► можно указать имя файла с помощью параметра filename. 
		
		Как передать дополнительные аргументы команде docker build …​ :
			► с помощью параметра additionalBuildArgs
		Пример: 
		
[Jenkinsfile]:		agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }.
		
		Пример репозитория с файлом build/Dockerfile.build, ожидающего версию аргумента сборки: 
		
		agent {
		// Equivalent to "docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/
		dockerfile {
			filename 'Dockerfile.build'
			dir 'build'
			label 'my-defined-label'
			additionalBuildArgs  '--build-arg version=1.0.2'
			args '-v /tmp:/tmp'
		}
	}
	

dockerfile also optionally accepts a registryUrl and registryCredentialsId parameters which will help to specify the Docker Registry to use and its credentials. For example:

agent {
    dockerfile {
        filename 'Dockerfile.build'
        dir 'build'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
    }
}



########################################################################################
########################################################################################
########################################################################################

# Jenkinsfile (Scripted Pipeline)

# В синтаксисе Scripted Pipeline один или несколько узловых блоков (node {stage('nameOfStage1'){//}stage('nameOfStage2'){//}...})
# выполняют основную работу во всем пайплайне.
# Хотя это не является обязательным требованием синтаксиса Scripted Pipeline, ограничение работы вашего конвейера внутри блока узла делает две вещи:
#	1. Планирует выполнение шагов, содержащихся в блоке, путем добавления элемента в очередь Jenkins. 
# 	   Как только исполнитель освободится на узле, шаги будут запущены.
# 	2. Создает рабочую область (каталог, относящийся к конкретному конвейеру), где можно выполнять работу с файлами, извлеченными из системы управления версиями.
#      Предупреждение. В зависимости от конфигурации Jenkins некоторые рабочие области могут не очищаться автоматически после определенного периода бездействия. 

node {  					# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stage('Build') { 		# Определяет стадию "Build". Блоки stage являются необязательными в синтаксисе Scripted Pipeline. 
							# Однако реализация блоков этапов в Scripted Pipeline обеспечивает более четкую визуализацию подмножества
							# задач/шагов каждого этапа в пользовательском интерфейсе Jenkins.
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Build"
    }
    stage('Test') { 		# Определяет стадию "Test"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Test"
    }
    stage('Deploy') { 		# Определяет стадию "Deploy"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
    }
}


Пример:

#!groovy
//Check ub1 properties
properties([disableConcurrentBuilds()])		# Запретить параллельную сборку несколькими пользователями

pipeline {
	agent {
		label 'main'		# указываем, что собираем в ветке main
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: '2', artifactNumToKeepStr: '2'))
		timestamps()
	}
	stages {
		stage("Create docker image") {
			steps {
				echo " ========== start building image ========== "
				dir ('path/to/the/Dockerfile/in/repo') {
				sh 'docker build -t pipeline_tests . '
				}
			}
		}
	}
}


############################################################################
############################################################################
############################################################################
############################################################################

* Jenkinsfile — это текстовый файл, содержащий определение пайплайна Jenkins и зарегистрированный в системе управления версиями.

Предполагается, что для проекта уже настроен репозиторий системы управления версиями, а пайплайн определен в Jenkins в соответствии с этими инструкциями.


# Jenkinsfile (Scripted Pipeline)

node {						# выделяет исполнителя и рабочее пространство для конвейера;
							# без узла Pipeline не может выполнять никакой работы
    checkout scm 			# scm — это специальная переменная, которая указывает шагу проверки клонировать конкретную ревизию, которая инициировала этот запуск Pipeline 
    /* .. snip .. */
}


################################

Шаг скрипта (сцкнария) берет блок Scripted Pipeline-а и выполняет его в декларативном конвейере.
В большинстве случаев шаг сценария не нужен в декларативных конвейерах, но он может предоставить полезный «аварийный выход».
Вместо этого блоки сценариев нетривиального размера и/или сложности следует перемещать в общие библиотеки (Shared Libraries).

Scripted Pipeline, как и Declarative Pipeline, построен поверх базовой подсистемы Pipeline.
В отличие от Declarative, Scripted Pipeline фактически представляет собой DSL общего назначения [2], созданный с помощью Groovy.
Большая часть функций, предоставляемых языком Groovy, доступна пользователям Scripted Pipeline, что означает, что он может быть очень выразительным и гибким инструментом, с помощью которого можно создавать Continuous Delivery Pipeline.

Scripted Pipeline выполняется последовательно, начиная с верхней части Jenkinsfile вниз, как и большинство традиционных сценариев в Groovy или других языках. Таким образом, обеспечение управления потоком основывается на выражениях Groovy, таких как условные операторы if/else, например:

###############################


https://docs.qameta.io/allure/#_jenkins
https://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow

https://www.jenkins.io/doc/pipeline/steps/allure-jenkins-plugin/
https://www.jenkins.io/doc/book/pipeline/syntax/	- Pipeline Syntax