# Плагины:
Multiselect parameter  -  работа с взаимосвязанными параметрами
Git parameter  -  выбор ветки репозиторий для сборки
Copy Artifact  -  копирование артефактов из другой сборки
Test Result Analyzer  -  анализ результатов тестов
Build Pipeline  -  удобное отображение upstream/downstream сборок
Git Changelog  -  отображение информации о коммите
Docker  -  Docker-контейнеры в качестве executors
Email Extension  -  гибкая настройка отправки email
Job Configuration History  -  изменения в настройках сборок


# Jenkinsfile (Declarative Pipeline)

# В синтаксисе декларативного пайплайна блок пайплайна определяет всю работу, выполняемую во всем пайплайне. 

pipeline {
    agent any 				# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stages {
        stage('Build') { 	# Определяет стадию "Build"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Build"
            }
        }
        stage('Test') { 	# Определяет стадию "Test"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Test"
            }
        }
        stage('Deploy') { 	# Определяет стадию "Deploy"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
            }
        }
    }
}

Декларативный pipeline - это относительно недавнее дополнение к Jenkins Pipeline, которое представляет более упрощенный и
самодостаточный синтаксис поверх подсистем pipeline.

Отличия Declarative Pipeline от синтаксиса Groovy:
	• верхний уровень Pipeline должен быть блоком, а именно: pipeline { };
    • точки с запятой не используются в качестве разделителей операторов, каждое выражение должно быть на отдельной строке;
    • блоки должны состоять только из разделов (Sections), директив (Directives), шагов (Steps) или операторов присваивания.
	• оператор ссылки на свойство рассматривается как вызов метода без аргументов. Так, например, ввод обрабатывается как input(). 

!!! В настоящее время существует нерешенная проблема, которая ОГРАНИЧИВАЕТ максимальный размер кода в блоке pipeline {}
	Это ограничение не распространяется на Scripted Pipeline 

Разделы (Sections):
	Разделы в Declarative Pipeline обычно содержат одну или более директиву (Directives) или шаг (Steps)

	agent
		
		Раздел agent указывает:
			► где будет выполняться весь pipeline, если расположен на самом верхнем уровне; ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ ЗАДАН
			► где будет выполняться определённый Stage, на уровне этапа (Stage)	-	НЕОБЯЗАТЕЛЬНО ЗАДАВАТЬ

		Различия между агентами высшего уровня (Top Level Agents) и агентами уровня этапа (Stage Agents)
		Top Level Agents:		
			параметры вызываются после входа в агент.
			Например, при использовании тайм-аута он будет применяться только к выполнению внутри агента

node("myAgent") {
    timeout(unit: 'SECONDS', time: 5) {
        stage("One"){
            sleep 10
            echo 'hello'
        }
    }
}

		Stage Agents
		параметры вызываются перед входом в агент и перед проверкой любых условий.
		В этом случае при использовании тайм-аута он применяется до выделения агента.
		
timeout(unit: 'SECONDS', time: 5) {
    stage("One"){
        node {
            sleep 10
            echo 'Hello'
        }
    }
}
	
		Этот тайм-аут будет включать время подготовки агента.
		Поскольку тайм-аут включает время подготовки агента, pipeline может дать сбой в тех случаях, когда выделение агента задерживается.
		
	Параметры
		Для поддержки широкого спектра вариантов использования, которые могут быть у авторов Pipeline,
		раздел агента поддерживает несколько различных типов параметров.
		Эти параметры могут применяться на верхнем уровне блока pipeline или внутри директивы каждого этапа. 
		
	• any
		выполняет Pipeline или этап на любом доступном агенте 
		pipeline {
			agent any
			...
		}
		
	• none
		при применении на верхнем уровне блока pipeline глобальный агент не будет выделен для всего запуска конвейера;
		каждый раздел этапа должен будет содержать свой собственный раздел агента
		pipeline {
			agent none
			...
		}
		
	• label
		выполненяет Pipeline или этап на агенте, доступном в окружении Jenkins с предоставленной меткой
		pipeline {
			agent agent { label 'my-defined-label' }
			...
		}
		
	• node
		
		
	• docker
		







########################################################################################
########################################################################################
########################################################################################

# Jenkinsfile (Scripted Pipeline)

# В синтаксисе Scripted Pipeline один или несколько узловых блоков выполняют основную работу во всем пайплайне.
# Хотя это не является обязательным требованием синтаксиса Scripted Pipeline, ограничение работы вашего конвейера внутри блока узла делает две вещи:
#	1. Планирует выполнение шагов, содержащихся в блоке, путем добавления элемента в очередь Jenkins. 
# 	   Как только исполнитель освободится на узле, шаги будут запущены.
# 	2. Создает рабочую область (каталог, относящийся к конкретному конвейеру), где можно выполнять работу с файлами, извлеченными из системы управления версиями.
#      Предупреждение. В зависимости от конфигурации Jenkins некоторые рабочие области могут не очищаться автоматически после определенного периода бездействия. 

node {  					# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stage('Build') { 		# Определяет стадию "Build". Блоки stage являются необязательными в синтаксисе Scripted Pipeline. 
							# Однако реализация блоков этапов в Scripted Pipeline обеспечивает более четкую визуализацию подмножества
							# задач/шагов каждого этапа в пользовательском интерфейсе Jenkins.
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Build"
    }
    stage('Test') { 		# Определяет стадию "Test"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Test"
    }
    stage('Deploy') { 		# Определяет стадию "Deploy"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
    }
}


Пример:

#!groovy
//Check ub1 properties
properties([disableConcurrentBuilds()])		# Запретить параллельную сборку несколькими пользователями

pipeline {
	agent {
		label 'main'		# указываем, что собираем в ветке main
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: '2', artifactNumToKeepStr: '2'))
		timestamps()
	}
	stages {
		stage("Create docker image") {
			steps {
				echo " ========== start building image ========== "
				dir ('path/to/the/Dockerfile/in/repo') {
				sh 'docker build -t pipeline_tests . '
				}
			}
		}
	}
}


############################################################################
############################################################################
############################################################################
############################################################################

Как обсуждалось в разделе «Определение конвейера в SCM», Jenkinsfile — это текстовый файл, содержащий определение конвейера Jenkins и зарегистрированный в системе управления версиями. Рассмотрим следующий конвейер, который реализует базовый трехэтапный конвейер непрерывной доставки.

Не все пайплайны будут иметь эти три стадии, но это хорошая отправная точка для определения их для большинства проектов. В разделах ниже показано создание и выполнение простого конвейера в тестовой установке Jenkins.

Предполагается, что для проекта уже настроен репозиторий системы управления версиями, а конвейер определен в Jenkins в соответствии с этими инструкциями.

С помощью текстового редактора, в идеале поддерживающего подсветку синтаксиса Groovy, создайте новый Jenkinsfile в корневом каталоге проекта.

Приведенный выше пример декларативного конвейера содержит минимально необходимую структуру для реализации конвейера непрерывной доставки. Требуемая директива агента указывает Дженкинсу выделить исполнителя и рабочее пространство для конвейера. Без директивы агента декларативный конвейер не только недействителен, но и не способен выполнять какую-либо работу! По умолчанию директива агента гарантирует, что исходный репозиторий извлечен и доступен для шагов на последующих этапах.

Директива stage и директивы steps также необходимы для действительного декларативного конвейера, поскольку они указывают Jenkins, что выполнять и на каком этапе это должно быть выполнено.

Для более расширенного использования со Scripted Pipeline приведенный выше пример узла является важным первым шагом, поскольку он выделяет исполнителя и рабочее пространство для конвейера.


# Jenkinsfile (Scripted Pipeline)

node {						# выделяет исполнителя и рабочее пространство для конвейера;
							# без узла Pipeline не может выполнять никакой работы
    checkout scm 			# scm — это специальная переменная, которая указывает шагу проверки клонировать конкретную ревизию, которая инициировала этот запуск Pipeline 
    /* .. snip .. */
}


https://docs.qameta.io/allure/#_jenkins
https://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow

https://www.jenkins.io/doc/pipeline/steps/allure-jenkins-plugin/
https://www.jenkins.io/doc/book/pipeline/syntax/	- Pipeline Syntax