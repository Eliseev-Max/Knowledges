ОС GNU/Linux
Устройство и функционирование

	- *nix, BSD и GNU
	- загрузка
	- состав
	- дистрибутивы

GNU появился раньше всех перечисленных выше систем
	Minix
	▼
	386BSD
	▼
	Linux
	
Линус Торвальдс не знал о появлении 386BSD
comp.os.minix

Каким был загрузчик первой версии Linux?
	Загрузчика не было.
	Команда file определяет по содержимому файла, что это за файл.
	/boot/(бинарные файлы ядра Linux)
	
	hexdump -C -n[количество байт]	- вывод в каноническом виде в шестнадцатеричной системе содержимого.
	Ядро Linux загружало само себя.
	Ядро записывалось на дискету (с нулевого смещения),
	содержало встроенный в себя загрузчик
	и загружало само себя
	
	Торвальдса не устраивал эхмулятор терминала Minix, поэтому он написал свой.
	Ядро стало больше и уже не влезало на дискету (1,44 Мб), загрузку с дискеты убрали.
	
	Самые популярные загрузчики:
		• GRUB v1/v2
		• LILO
		• syslinux /
		•• pxeLinux (Preboot Execution Environment) - загрузка по сети /
		•• ISOLinux - загрузчик с компакт-диска/DVD
		• uBoot
	
[00:21:43]  Существенное отличие GRUB и LILO (в пользу GRUB)
	
	Конфигурация загрузчика:
		/boot/grub/grub.cfg
		/boot/grub/menu.lst
		/etc/lilo.conf
		syslinux.cfg
	
	Если мы совершили ошибку и забыли запустить команду lilo перед перезагрузкой,
	когда внесли изменения в конфигурационный файл lilo.conf, то ничего не произойдёт:
	загрузка будет происходить со старыми параметрами. (если при этом удалить старое ядро,
	то старые параметры будут использоваться для загрузки нового ядра. Могут возникнуть сложности).
	У GRUB первые 2 файла (оба названия конфигурационного файла) на командном языке загрузчика исполняется каждый раз при старте.
	Нет опасности внести изменения и забыть "сказать об этом" загрузчику.
	
	GUID/UUID уникальный идентификатор файловой системы (он не повторяется).
	Команда uuidgen - генератор UUID
	
	Распечатать) содержимое суперблока:
	$ sudo tune2fs -l /dev/sda
	или
	$ sudo tune2fs -l /dev/sda2
	Возможный вариант вывода команды:
	  Bad magic number in super-block while trying to open /dev/sda2
	  Couldn't find valid filesystem superblock.
	действует аналогично утилите file (смотрит в начало файла и пытается определить, что это за файл, по структуре и содержимому первых строк)
	
[00:31:36]  Ядро Linux
	
	Гибридное: драйверы дисковых и фаловых подсистем загружаются модулями.
	Модули можно подгружать, когда они нужны, и выгружать, когда уже не нужны.
	Модули - файлы в директории /lib/modules/
	
	Разработчики Linux НЕ РЕКОМЕНДУЮТ пересобирать ядро.
	
	Команда lsmod
	Можно поискать в её выводе наличие определённой ФС:
		$ lsmod |grep ext
	
	Файловая система ext включена в некоторых дистрибутивах в состав ядра.
	
[00:36:55]  Как происходит загрузка ядра? (Как работает bootstrapping?)
	Загрузчик загрузил в память ядро и передал ему управление.
	Термин bootstrapping появился ещё до создания компьютеров.
	Означает примерно "компьютер сам себя загрузил"
	Ядро одно, а компьютеры разные. Необходимо сконфигурировать ядро перед его загрузкой.
	
	Как настроить ядро до его запуска?
	Параметрами!
	С точки зрения настройки ядро не сильно отличается от программных утилит, запускаемых через командную строку.
	Ядро получает командную строку (и даже в Windows)
	д
	Параметры:
		BOOT_IMAGE = (путь до архива ядра). Внесён загрузчиком.
		root=... - сообщает ядру, с какой файловой системой придётся иметь дело (указывает корневую файловую систему)
		root - очень важный параметр.
		# команда blkid
		crash_kernel - указывает место, куда помещается копия ядра. Дамп памяти ядра.
		quiet - не выводить информацию, кроме сообщений об ошибке
		splash - всплывающий графический экран при загрузке
	
	/var/log/dmesg - файл, содержащий сообщения, которые ядро должно выводить на консоль (но могло не выводить)
	
[00:45:50]  Как настроить ядро после запуска?
	
	У ядра есть переменные, влияющие на его поведение.
	Утилита sysctl
	Переменных у ядра больше 1000.
	Пример переменной: net.ipv4.ip_forward
	sysctl -w net.ipv4.ip_forward = 1
	Часто приводится в качестве примера при использовании виртуальных машин (настройка маршрутизации).
	
	Если не предполагается перезагружаться, изменить значение переменной можно с помощью файлового интерфейса /proc/
	$ echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
	? Почему используется такая синтаксическая конструкция, а не 
		$ sudo echo 1 > /proc/sys/net/ipv4/ip_forward
	Потому что в команде выше повышение привилегий происходит позже, чем перенаправление вывода в файл.
	Пеернаправление вывода в файл происходит от текущего пользователя, а команда echo выполняется от суперпользователя.
	В итоге имеем недостаток прав доступа.
	/etc/sysctl.conf
	Применить изменения в отредактированном конфигурационном файле (перепрочесть):
		$ sudo sysctl -p
	
	<Поиск в конфигурационном файле при помощи grep>:
	$ grep -v ^# /etc/sysctl.conf
	-v = пропустить строки, которые совпадают в шаблоне
	^# - (регулярные выражения) - начиная с #
	$ grep -v ^#.*ip_forward /etc/sysctl.conf
	
	Параметр kernel.panic  (ситуация, когда ядро не знает, что делать дальше)
	По умолчанию kernel.panic = 0 		# остановиться и ничего не предпринимать
	Документация ядра: Magic SRQ (возможность перезагрузиться)
	Если установить значение kernel.panic =[>0] (число больше 0), ПК перезагрузится через это число секунд.
	Если kernel.panic <0 → panic_blink() - мигание лампочками клавиатуры.
	
	4 значения kernel.panic:
		kernel.panic = 0
		kernel.panic_on_oops = 0
		kernel.panic_on_unrecovered_nmi = 0
		kernel.panic_on_io_nmi = 0
	
	Команда more в отличие от команды less не умеет читать назад в потоке (если вывод передан ей через пайп | )
	
[01:10:25]  Как появляются новые процессы
	
	Новые процессы появляются с помощью одной функции без параметров: функции fork()
	[Усовершенствование] → Заменена на clone
	[Усовершенствование] → Заменена на clone2
	
[01:11:15]  Откуда появляется init?
		/sbin/init; PID = 1
		Значение памяти процессов, созданных ядром = 0 означает,
		что память в пользовательском режиме не потребляется этими процессами
		вся память = память ядра
...
...
...
	init относится к пакету upstart
	раньше относился к ...
	
	Варианты init
	BSD-стиль
	
	SysV-стиль
	

[ конспект статьи: https://ubuntu.com/server/docs/kernel-crash-dump
Дамп сбоя ядра (Kernel Crash Dump) относится к части содержимого энергозависимой памяти (ОЗУ),
которая копируется на диск всякий раз, когда выполнение ядра прерывается.
Следующие события могут вызвать нарушение работы ядра:
	• Kernel Panic					[A]
	• Non Maskable Interrupts (NMI)	[A]	 {Немаскируемые прерывания}
	• Machine Check Exceptions (MCE) 	 {Исключения машинной проверки}
	• Аппаратный сбой (Hardware failure)
	• Ручное вмешательство (Manual intervention)

Для некоторых из этих событий (Kernel Panic, NMI) ядро отреагирует автоматически 
и запустит механизм аварийного дампа через kexec.
В других ситуациях требуется ручное вмешательство для захвата памяти.
Всякий раз, когда происходит одно из вышеперечисленных событий, важно выяснить основную причину, чтобы предотвратить его повторение.
Причину можно определить, проверив скопированное содержимое памяти.
Механизм Kernel Crash Dump
	[Kernel Panic] → запускается механизм kexec → быстрая перезагрузка нового экземпляра ядра 
												  в заранее зарезервированном разделе памяти,
												  который был выделен при загрузке системы
	* Это позволяет сохранить существующую область памяти нетронутой,
	  чтобы безопасно скопировать ее содержимое в хранилище
	Утилита kernel crash dump устанавливается командой:
	$ sudo apt install linux-crashdump
	Начиная с версии Ubuntu 16.04 механизм kernel crash dump доступен по умолчанию.
	Как активировать механизм вручную?
	1. Командами 
		dpkg-reconfigure kexec-tools 	и
		dpkg-reconfigure kdump-tools
	2. Отредактировать файл /etc/default/kexec:
		Установить значение параметра LOAD_KEXEC равным true
		# Load a kexec kernel (true/false)
		LOAD_KEXEC=true
	2.1 Также можно отредактировать /etc/default/kdump-tools: USE_KDUMP=1
Для более подробной информации читать статью.
]

