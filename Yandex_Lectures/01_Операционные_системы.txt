Операционные системы

[00:04:47]	Операционная система в первую очередь предоставляет среду для исполнения приложений.
			Делает она это через свои библиотеки и свои системные вызовы (интерфейс системных вызовов).
	* Утилита strace

[00:05:40]	Какие существуют операционные системы:
	
	• Microsoft Windows
	• GNU Linux
	• MacOS
	• BSD → MacOS, IOS
	• Solaris
	• HP UX
	• WebOS
	• OS2 (E-station?)
	• Plan9
	• React OS (~ядро NT)
	• Kalibrix
	• AIX
	• QNX
	• DOS, FreeDOS
	• Symbian
	• Minix
	• Blackberry OS
	• Minuet OS
	• NeXTSTEP (от компании NeXT)
	
[00:09:40]
	Сколько ОС в телефоне?
	Как минимум, две: одна - ОС смартфона, одна - на SIM-карте.

[00:10:30]	UNIX®
	
	1969г. (AT&T/Bell Labs: Томпсон, Керниган, Ритчи)
	Распространялась свободно
	Стандарт де-факто и де-юре (POSIX)
	POSIX = Portable Operating System Interface [for UniX]
	POSIX мобильна.
	AIX, Solaris, MacOS X/FreeBSD/NetBSD/OpenBSD - генетически UNIX®
	Linux, Minix - реализации
	
	У Minix была проблема с лицензией: она была не достаточно свободной.
	Можно было делать свои модификации, но нельзя было распространять модифицированные версии.
	Сначала Линуса Торвальдса не устроил эмулятор терминала Minix,
	→ затем он внёс исправления, чтобы появилась 	возможность загружаться с дискеты
	→ потом понадобилась файловая система, совместимая с Minix
	... в конце концов он обнаружил, что у него получилась ОС
	
	Есть реализации POSIX для Windows (в Windows можно доустановить POSIX-систему)
	UNIX - зарегистрированный товарный знак (торговая марка), поэтому стали использовать обозначение: *nix
	
[00:17:00] Вкратце о том, какие стандарты описаны в POSIX
		   
	Для того, чтобы программа могла исполняться, должно сохраняться следование стандарту.
	  ◘ библиотечный стандарт для языков C/C++ (STL)
	  ◘ другой вариант написать переносимую программу: написать её для некой среды исполнения.
	► Runtime (термин возник в связи с идеей при загрузке машины загружать в память набор необходимых библиотек)
	
	Среды исполнения:
	  • Shell
	  • Java
	  • Perl/Python (любой интерпретируемый язык программирования)

[00:18:05] Какие функции должна выполнять ОС
	
	Чего программы хотят от ОС:
		• абстракцию оборудования;
		• координацию совместной работы с устройствами;
		• изоляцию сбойных приложений;
		• обмен между приложениями.

[00:21:10] Как устроена ОС
	
	   [Пользователь]
		    ▲ ▼
	    [Приложение]
		    ▲ ▼
	[Операционная система]
		    ▲ ▼
	   [Оборудование]

	Существуют ОС с экзоядром, которые не обеспечивают изоляцию программ от оборудования.
	Например ОС в SIM-картах
	
[00:22:05]	Какие сервисы предлагает ОС?
			♦ Процессы
			♦ Память
			♦ Содержимое файлов (возможность работы с файлами)
			♦ Каталоги и имена файлов
			♦ Безопасность
			♦ ...(пользователи, IPC, сеть, терминалы)
			  IPC - взаимодействие между процессами

[00:24:30]	Как приложения обращаются к системе?
			ABI - syscalls		# Системные вызовы
	# Параметры ниже передаются через регистры
	mov edx,len										# Загрузить в регистр edx (32-разрядный) длину сообщения
	mov ecx,msg										# Загрузить в регистр ecx адрес сообщения
	mov ebx,1		;file descriptor (stdout)		# ebx - Регистр, указывающий, в какой файл будет производиться запись [*]
	mov eax,4		;system call number (sys_write)	# Загрузить в регистр eax номер системного вызова
	int    0x80		;call kernel					# команда процессора на программное прерывание
	mov    eax,1	;system call number				# Записать в регистр eax код завершения
	(sys_exit)
	int    0x80		;call kernel
	section  .data
	    'Hello, world!' ,0xa
	
	[*] в системах UNIX 0 = стандартный вход (STDIN), 1 = стандартный выход (STDOUT)
	
	В рамках процессоров Intel и совместимых с ними системные вызововы - это, как правило, прерывания
	В ОС Windows это прерывание 2e (16x-запись)
	int = на время запретить другие прерывания и произвести вызов ОС
	nasm - команда ассемблирования
	После процедуры ассемблирования получается файл filename.o - это объектный файл, не годится для выполнения
	gdb - отладчик, под ним можно запускать программы
	
[00:31:50]	Что плохо в этом примере?
	
	▲ Так не пишут.
	
	Другой пример написания:
	
	int main(){
		__asm__(
			"movl $20, %eax	    \n"			# $20 = загрузить константу
			"call *%gs:0x10    \n"
			"movl %eax, pid    \n"
		);
		printf("pid is %d\n", pid);
		return 0;
	}
	Сейчас не используется прерывание int 80;
	Используют sysenter и sysexit
	
	Классический Linux использует для загрузки пакет initscripts
	В нём есть конфигурационный файл /etc/inittab
		→ id:5:initdefault (5 = запуск графической оболочки)
	
[00:37:00]	Как понять, что происходит при работе программы?

	Утилита strace
	
	$ strace опции команда аргументы
	
	Она показывает каждый системный вызов, который делает программа
	$ strace ./program_name
	strace позволяет, не имея исходников, методом "чёроного ящика" посмотреть, в каком месте программа прекращает работу.
	strace -f		-f = follow_forks, следовать за потомками - отслеживать дочерние процессы.
	strace -e		[-e] позволяет фильтровать по искомому значению.
	
	$ strace -f -e open sh		найти все open в выводе утилиты
	
	Системные вызовы
		• fork - создание нового дочернего процесса;
		• read - попытка читать из файлового дескриптора;
		• write - попытка записи в файловый дескриптор;
		• open - открыть файл для чтения или записи;
		• close - закрыть файл после чтения или записи;
		• chdir - изменить текущую директорию;
		• execve - выполнить исполняемый файл;
		• stat - получить информацию о файле;
		• mknod - создать специальный файл, например, файл устройства или сокет;

	
	Утилита ltrace
		- посмотреть библиотечные вызовы
	
[00:44:22]	Shell: /bin/*sh (программная оболочка)
	* Интерпретатор команд *nix
	
	while (1) {						# вечный цикл
		write (1, "$", 2);			# запись на STDOUT (1)
		readcmd (cmd, args);	// parse user input
		if ((pid = fork()) == 0) {  // child?	# ключевой вызов в UNIX [*]
			exec (cmd, args, 0);				# дочерний процесс выполняет заданную команду (exec)
		} else if (pid > 0) {  // parent?
			wait (0);		   //wait for child to terminate	# родительский процесс должен ждать (если потомок создан и pid>0)
		} else {				# если не произошло ни того, ни другого, дать сообщение об ошибке.
			perror ("fork");	# стандартная функция, знает все коды ошибок, может их напечатать
		}
	}
	
	[*] процесс в памяти разделяется на два идентичных экземпляра, различающихся кодом возврата функции.
		у дочернего процесса код возврата = 0 (при успешном выполнении)
		у родительского процесса код возврата = 
			- код ошибки, если не был создан дочерний процесс;
			- PID дочернего процесса

[00:46:35] Что делает код:
	
	Системные вызовы:
		• read
		• write
		• fork
		• exec
		• wait
	Соглашения:
		- при ошибке код возврата -1
		- код ошибки заносится в errno						# переменная в библиотеке
		- функция perror выводит сообщение об ошибке errno
	
[00:46:57]  Вызов: fork
	(Клонирует процесс в памяти)
	Создаёт потомка, точную копию вызвавшего процесса, и возвращает управление родителю и потомку
	У родителя и потомка совпадают:
		- память процесса (код, данные, стек)
		- атрибуты процесса: владелец, права, контекст
	Отличаются:
		- PID
		- Код возврата при успешном fork
			♦ у потомка 0
			♦ у родителя PID потомка
	
	# В UNIX предполагалось, что каждый процесс - это единица исполнения.
	# Если нужно выполнить что-то параллельно, создаётся ещё один процесс.
	# Но в целях экономии ресурсов создают дополнительную нить (поток) - pthread;
	# у процесса может быть несколько нитей (потоков).
	# Если нитей было несколько, то дочерний процесс будет иметь только ОДНУ нить.
	Поэтому создали новый метод clone (похожий на fork)
	clone - функция-заглушка в библиотеке, делает системный вызов, который ведёт себя точно так же, как fork.
	clone в зависимости от заданных параметров может
		► сохранять для дочернего процесса все нити;
		► оставлять дочернему процессу только одну нить (как fork)
	
[00:49:00]	Вызов: exec

	После fork ОС, такая как Linux и UNIX, выполняет exec.
	exec замещает содержимое памяти вызвавшего процесса инструкциями и данными из файла на диске,
		то есть исполняет файл.
	Процесс остаётся тем же = сохраняет PID, UID, ...
	
[00:51:53]  Вызов: wait
	
	Ожидает завершения одного из потомков
	  Зачем? Что будет, если потомок заветшится раньше wait?
	  ▬ Получится процесс-"зомби".
	  "Зомби" - это процесс, память от которого освобождена, но осталась запись о нём в таблице процессов
				(памяти он не занимает, а запись в таблице есть)
	  В строчке в таблице процессов содержится код возврата
	  Если родительский процесс аварийно завершается, то 
	    • дочерний процесс "осиротеет",
		•• его унаследует первый процесс init
	  
[00:52:54]  Почему fork/exec разделены?
	
	1. Как ls узнает текущий каталог, (stdin, stdout)?
		- Наследует cwd и открытые файлы от родителя:
		т.к. она наследует открытые файлы, она наследует в т.ч. атрибут процесса: текущий каталог;
		текущий каталог получается таким же, как у родителя;
		♦ первым вызовом fork происходит наследование всего
		♦ вызовом exec замещается код процесса, который должен исполняться

	2. Технология UNIX/Linux Copy-on-write (копирование по записи) делает fork очень быстрым
	   Операция клонирования фактически не копирует память, 
	   а назначает одни и те же участки памяти двум процессам сразу через механизм виртуальной памяти.
	   fork - это очень быстрый вызов.
	   
[00:54:17]  Вызоы: read/write
	
	Аргументы:
		- номер файла;
		- указатель на буфер;		# где строка, которую нужно прочитать/в которую нужно записать
		- число байтов
	Возвращает число байтов
	
[00:54:36]  Организация ОС: традиционный подход
	
	ОС производит абстракцию оборудования следующим образом:
	Виртуализуется часть ресурсов
		- ЦПУ			# процесс "думает", что он монопольно владеет всем процессорным временем
		- память		# процесс "думает", что вся память в его распоряжении
						# он делает всё, что хочет, по своим адресам памяти
	
	Каждое приложение "монопольно" ими распоряжается
	
	Зачем?
		- Так проще писать приложения
		*nix, Windows NT

[00:55:55]	Пример: виртуализация ЦПУ

	Цель: эмулировать отдельный ЦПУ для каждого процесса
		- Переключение ЦПУ прозрачно
		- Процессу не нужно беспокоиться о других процессах
		
	ОС выполняет процессы по очереди до прерывания по таймеру.
	Таймер позволяет процессу не беспокоиться о переключениях.
	
	# Как правило прерывания происходят по таймеру 
	(когда ОС должна остановить исполнение одного процесса и "отдать" процессор другому процессу)
	Периодически "просыпается" по аппаратному генератору сигналов в процессоре и принимает решение: нужно отобрать или нет
	За это отвечает специальная нить (поток) в ядре, которая называется Планировщик (Scheduler).

[00:56:20]  Как происходит переключение между процессами?
	
	- ОС сохраняет и восстанавливает состояние (контекст) ЦПУ при каждом переключении
	Что сохраняется (что входит в контекст приложения)?
		• Регистры (eax, ebx, ecx...),
		• флаги состояния,
		• указатели на таблицы виртуальной памяти
	
	Где сохраняется?
		- В таблице процессов
	
	Прерывание таймера приводит к переключению на другой процесс

[00:57:12]  Как можно посмотреть за происходящим?
	
	1. vmstat
		без аргументов выводит одну строку
		|cs| - переключение контекста в секунду (среднее значение)
		(см. man)
		Последние 2 строки:
		voluntary_ctxt_switches (добровольное переключение контекста): процесс совершил системный вызов и отдал ресурсы.
		nonvoluntary_ctxt_switches (недобровольное переключение контекста): прервано ОС
	
	2. ps [aux, -e]  - снимок состояния процессов
	
[01:02:05]  Виртуализация памяти
	
	Идея: для процессора доступно:
		- всё адресное пространство 2^32
		- оно ссылается на его "частную память"
	
	Физическая память одна. Но поскольку все процессы изолированы друг от друга
	(каждый процесс находится в своём адресном пространстве), каждый процесс считает, что он находится в оперативной памяти один.
		+ Удобно
		+ Безопасно
		
	В 32-битных ОС процесс получает в своё распоряжение не все 4 ГБ (из 4), а меньше,
	поскольку часть памяти выделяется ядру (для хранения структур).

[01:03:00]  Варианты виртуализации памяти
	
	► Вытеснение процесса на диск при переключении
		- медленно
		- имело смысл в 90-х
		
	► Использование сегментов x86
		- переключать сегменты CS, DS на разные адреса
		- фрагментация памяти
		
	► Применить страничный механизм ЦПУ
	  [Всё адресное пространство разбивается на блоки по 4К = страницы памяти]
		- таблица физических адресов каждого 4К блока - страницы памяти
		- это таблица страниц
		- страницы можно помечать недействительными и переносить в подкачку - на диск
		- при обращении к такой странице возникает прерывание, и страницу можно загрузить обратно
		- copy-on-write - избавить fork от копирования памяти
	
	Команды:
		$ swapon -s
		
		$ free
		
[01:05:12]  Подходы к построению систем

	♦ Монолитное ядро
	♦ Гибридное (модульное) ядро
	♦ Микроядро <Minix>
	♦ Экзоядро (программа имеет прямой доступ к оборудованию, часть функционала она реализует сама)
	
[01:05:55]  Планирование процессорного времени
	
	* Многозадачность:
		• Кооперативная (Windows 3.1, Mac OS 9, WOW16 = 16-разрядная)
		• Вытесняющая (preemptive)		# ОС умеет "силой" отбирать процессорное время
	
[01:06:24]  Планирование процессорного времени

	Долгосрочное
		• batch (при невысокой нагрузке на процессор; команды выполняются в порядке очереди)
	Среднесрочное
		- BSD: выгрузка в подкачку неактивных процессов
		- Android: завершение задач при нехватке памяти (процессу даётся шанс сохранить своё состояние)
	Краткосрочное
		- Планировщик ЦПУ в ядре
	
[01:07:20]  Алгоритмы планировщика ЦПУ
	
	• FIFO/FCFS
	• SJF (Shortest Job First)
	• Приоритетное планирование (OCPB)
	• Round-Robin
	• Многоуровневые очереди с обратной связью
		► CFQ
	
[01:07:37]  Управление памятью
	
	• Распределение
	• Защита
	• Разделение (sharing)		# = совместное использование памяти несколькими процессами (например СУБД: память+кэш)
	• Логическая организация (сегменты)
	• Физическая организация (подкачка)

[01:08:16]  Планирование ввода-вывода
	
	Цели:
		- сократить время поиска диском
		- приоритезировать ввод-вывод
		- разделить полосу пропускания устройства между процессами
		- гарантировать исполнение запросов не позднее крайнего срока
	
	Сначала данные пишутся в буферный кэш HDD, далее принимается решение, какие данные должны быть записаны на HDD
	
	В Linux можно выбирать алгоритм планирования, который будет использоваться системой.
	Реализации:
		• случайное планирование (RSS)
		• FIFO/FCFS
		• LIFO
		• CFQ (* Completely Fair Queuing - "справедливый" планировщик)
		• SCAN (лифт)
		• Noop (FIFO с объединением) [для виртуальной машины]
		• Anticipatory (упреждающий)
		• Deadline (отдаёт весь ввод-вывод конкретному процессу, затем отнимает у него и отдаёт следующему)
	
[01:10:06]  Управление памятью

	Кэш-буфер
	Промахи страниц (процесс обратился по адресу к памяти, а её там нет. ОС обрабатывает это как промах)
		- жёсткие (если данные уже на диске)
		- мягкие (если данные ещё в кэше)
	
	Алгоритмы виртуальной памяти
		- LRU
		- Опережающая подгрузка
		- ...
	
[01:10:45]  Производительность в числах
	(Когда это может быть важно?)
	(см. скриншот)

[01:12:26]  Примеры
	
	Чем плох системный вызов int?
		► int занимает 			>> 400 нс
		► sysenter занимает 	400 нс