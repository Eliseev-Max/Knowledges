Операционные системы

[00:04:47]	Операционная система в первую очередь предоставляет среду для исполнения приложений.
			Делает она это через свои библиотеки и свои системные вызовы (интерфейс системных вызовов).
	* Утилита strace

[00:05:40]	Какие существуют операционные системы:
	
	• Microsoft Windows
	• GNU Linux
	• MacOS
	• BSD → MacOS, IOS
	• Solaris
	• HP UX
	• WebOS
	• OS2 (E-station?)
	• Plan9
	• React OS (~ядро NT)
	• Kalibrix
	• AIX
	• QNX
	• DOS, FreeDOS
	• Symbian
	• Minix
	• Blackberry OS
	• Minuet OS
	• NeXTSTEP (от компании NeXT)
	
[00:09:40]
	Сколько ОС в телефоне?
	Как минимум, две: одна - ОС смартфона, одна - на SIM-карте.

[00:10:30]	UNIX®
	
	1969г. (AT&T/Bell Labs: Томпсон, Керниган, Ритчи)
	Распространялась свободно
	Стандарт де-факто и де-юре (POSIX)
	POSIX = Portable Operating System Interface [for UniX]
	POSIX мобильна.
	AIX, Solaris, MacOS X/FreeBSD/NetBSD/OpenBSD - генетически UNIX®
	Linux, Minix - реализации
	
	У Minix была проблема с лицензией: она была не достаточно свободной.
	Можно было делать свои модификации, но нельзя было распространять модифицированные версии.
	Сначала Линуса Торвальдса не устроил эмулятор терминала Minix,
	→ затем он внёс исправления, чтобы появилась 	возможность загружаться с дискеты
	→ потом понадобилась файловая система, совместимая с Minix
	... в конце концов он обнаружил, что у него получилась ОС
	
	Есть реализации POSIX для Windows (в Windows можно доустановить POSIX-систему)
	UNIX - зарегистрированный товарный знак (торговая марка), поэтому стали использовать обозначение: *nix
	
[00:17:00] Вкратце о том, какие стандарты описаны в POSIX
		   
	Для того, чтобы программа могла исполняться, должно сохраняться следование стандарту.
	  ◘ библиотечный стандарт для языков C/C++ (STL)
	  ◘ другой вариант написать переносимую программу: написать её для некой среды исполнения.
	► Runtime (термин возник в связи с идеей при загрузке машины загружать в память набор необходимых библиотек)
	
	Среды исполнения:
	  • Shell
	  • Java
	  • Perl/Python (любой интерпретируемый язык программирования)

[00:18:05] Какие функции должна выполнять ОС
	
	Чего программы хотят от ОС:
		• абстракцию оборудования;
		• координацию совместной работы с устройствами;
		• изоляцию сбойных приложений;
		• обмен между приложениями.

[00:21:10] Как устроена ОС
	
	   [Пользователь]
		    ▲ ▼
	    [Приложение]
		    ▲ ▼
	[Операционная система]
		    ▲ ▼
	   [Оборудование]

	Существуют ОС с экзоядром, которые не обеспечивают изоляцию программ от оборудования.
	Например ОС в SIM-картах
	
[00:22:05]	Какие сервисы предлагает ОС?
			♦ Процессы
			♦ Память
			♦ Содержимое файлов (возможность работы с файлами)
			♦ Каталоги и имена файлов
			♦ Безопасность
			♦ ...(пользователи, IPC, сеть, терминалы)
			  IPC - взаимодействие между процессами

[00:24:30]	Как приложения обращаются к системе?
			ABI - syscalls		# Системные вызовы
	# Параметры ниже передаются через регистры
	mov edx,len										# Загрузить в регистр edx (32-разрядный) длину сообщения
	mov ecx,msg										# Загрузить в регистр ecx адрес сообщения
	mov ebx,1		;file descriptor (stdout)		# ebx - Регистр, указывающий, в какой файл будет производиться запись [*]
	mov eax,4		;system call number (sys_write)	# Загрузить в регистр eax номер системного вызова
	int    0x80		;call kernel					# команда процессора на программное прерывание
	mov    eax,1	;system call number				# Записать в регистр eax код завершения
	(sys_exit)
	int    0x80		;call kernel
	section  .data
	    'Hello, world!' ,0xa
	
	[*] в системах UNIX 0 = стандартный вход (STDIN), 1 = стандартный выход (STDOUT)
	
	В рамках процессоров Intel и совместимых с ними системные вызововы - это, как правило, прерывания
	В ОС Windows это прерывание 2e (16x-запись)
	int = на время запретить другие прерывания и произвести вызов ОС
	nasm - команда ассемблирования
	После процедуры ассемблирования получается файл filename.o - это объектный файл, не годится для выполнения
	gdb - отладчик, под ним можно запускать программы
	
[00:31:50]	Что плохо в этом примере?
	
	▲ Так не пишут.
	
	Другой пример написания:
	
	int main(){
		__asm__(
			"movl $20, %eax	    \n"			# $20 = загрузить константу
			"call *%gs:0x10    \n"
			"movl %eax, pid    \n"
		);
		printf("pid is %d\n", pid);
		return 0;
	}
	Сейчас не используется прерывание int 80;
	Используют sysenter и sysexit
	
	Классический Linux использует для загрузки пакет initscripts
	В нём есть конфигурационный файл /etc/inittab
		→ id:5:initdefault (5 = запуск графической оболочки)
	
[00:37:00]	Как понять, что происходит при работе программы?

	Утилита strace
	Она показывает каждый системный вызов, который делает программа
	$ strace ./program_name
	strace позволяет, не имея исходников, методом "чёроного ящика" посмотреть, в каком месте программа прекращает работу.
	strace -f		-f = follow_forks, следовать за потомками - отслеживать дочерние процессы.
	strace -e		[-e] позволяет фильтровать по искомому значению.
	
	$ strace -f -e open sh		найти все open в выводе утилиты
	
	Утилита ltrace
		- посмотреть библиотечные вызовы
	
[00:44:22]	Shell: /bin/*sh (программная оболочка)
	* Интерпретатор команд *nix
	
	while (1) {						# вечный цикл
		write (1, "$", 2);			# запись на STDOUT (1)
		readcmd (cmd, args);	// parse user input
		if ((pid = fork()) == 0) {  // child?	# ключевой вызов в UNIX [*]
			exec (cmd, args, 0);				# дочерний процесс выполняет заданную команду (exec)
		} else if (pid > 0) {  // parent?
			wait (0);		   //wait for child to terminate	# родительский процесс должен ждать (если потомок создан и pid>0)
		} else {				# если не произошло ни того, ни другого, дать сообщение об ошибке.
			perror ("fork");	# стандартная функция, знает все коды ошибок, может их напечатать
		}
	}
	
	[*] процесс в памяти разделяется на два идентичных экземпляра, различающихся кодом возврата функции.
		у дочернего процесса код возврата = 0 (при успешном выполнении)
		у родительского процесса код возврата = 
			- код ошибки, если не был создан дочерний процесс;
			- PID дочернего процесса

[00:46:35] Что делает код:
	
	Системные вызовы:
		• read
		• write
		• fork
		• exec
		• wait
	Соглашения:
		- при ошибке код возврата -1
		- код ошибки заносится в errno						# переменная в библиотеке
		- функция perror выводит сообщение об ошибке errno
	
[00:46:57]  Вызов: fork
	(Клонирует процесс в памяти)
	Создаёт потомка, точную копию вызвавшего процесса, и возвращает управление родителю и потомку
	Совпадает:
		- память процесса (код, данные, стек)
		- атрибуты процесса: владелец, права, контекст
	Отличаются:
		- PID
		- Код возврата при успешном fork
			♦ у потомка 0
			♦ у родителя PID потомка
	
	# В UNIX предполагалось, что каждый процесс - это единица исполнения.
	# Если нужно выполнить что-то параллельно, создаётся ещё один процесс.
	# Но в целях экономии ресурсов создают дополнительную нить - pthread; у процесса может быть несколько нитей.
	# Если нитей было несколько, то дочерний процесс будет иметь только ОДНУ нить.
	Поэтому создали новый метод clone (похожий на fork)
	clone - функция-заглушка в библиотеке, делает системный вызов, который ведёт себя точно так же, как fork.
	clone в зависимости от заданных параметров может
		► сохранять для дочернего процесса все нити;
		► оставлять дочернему процессу только одну нить (как fork)
	
[00:49:00]	Вызов: exec

	После fork ОС, такая как Linux и UNIX, выполняет exec.
	exec замещает содержимое памяти вызвавшего процесса инструкциями и данными из файла на диске,
		то есть исполняет файл.
	Процесс остаётся тем же = сохраняет PID, UID, ...
	
[00:51:53]  Вызов: wait
	
	Ожидает завершения одного из потомков
	  Зачем? Что будет, если потомок заветшится раньше wait?
	  ▬ Получится процесс-"зомби".
	  "Зомби" - это процесс, память от которого освобождена, но осталась запись о нём в таблице процессов
				(памяти он не занимает, а запись в таблице есть)
	  В строчке в таблице процессов содержится код возврата
	  Если родительский процесс аварийно завершается, то дочерний процесс "осиротеет", и его унаследует первый процесс init
	  
[00:52:54]  Почему fork/exec разделены?
	
	1. Как ls узнает текущий каталог, (stdin, stdout)?
		- Наследует cwd и открытые файлы от родителя:
		т.к. она наследует открытые файлы, она наследует в т.ч. атрибут процесса: текущий каталог;
		текущий каталог получается таким же, как у родителя;
		♦ первым вызовом fork происходит наследование всего
		♦ вызовом exec замещается код процесса, который должен исполняться

	2. Технология UNIX/Linux Copy-on-write (копирование по записи) делает fork очень быстрым
	   Операция клонирования фактически не копирует память, 
	   а назначает одни и те же участки памяти двум процессам сразу через механизм виртуальной памяти.
	   fork - это очень быстрый вызов.
	   
[00:54:17]  Вызоы: read/write
	
	Аргументы:
		- номер файла;
		- указатель на буфер;		# где строка, которую нужно прочитать/в которую нужно записать
		- число байтов
	Возвращает число байтов
	
[00:54:36]  Организация ОС: традиционный подход
	
	ОС производит абстракцию оборудования следующим образом:
	Виртуализуется часть ресурсов
		- ЦПУ			# процесс "думает", что он монопольно владеет всем процессорным временем
		- память		# процесс "думает", что вся память в его распоряжении
						# он делает всё, что хочет, по своим адресам памяти
	
	Каждое приложение "монопольно" ими распоряжается
	
	Зачем?
		- Так проще писать приложения
		*nix, Windows NT

[00:55:55]	Пример: виртуализация ЦПУ

	Цель: эмулировать отдельный ЦПУ для каждого процесса
		- Переключение ЦПУ прозрачно
		- Процессу не нужно беспокоиться о других процессах
		
	ОС выполняет процессы по очереди до прерывания по таймеру.
	Таймер позволяет процессу не беспокоиться о переключениях.
	
	# Как правило прерывания происходят по таймеру 
	(когда ОС должна остановить исполнение одного процесса и "отдать" процессор другому процессу)
	Периодически "просыпается" по аппаратному генератору сигналов в процессоре и принимает решение: нужно отобрать или нет
	За это отвечает специальная нить в ядре, которая называется Планировщик.

[00:56:20]  Как происходит переключение между процессами?
	
		- ОС сохраняет и восстанавливает состояние (контекст) ЦПУ при каждом переключении
	Что сохраняется (что входит в контекст приложения)?
		• Регистры (eax, ebx, ecx...),
		• флаги,
		• указатели на таблицы виртуальной памяти
	
	Где сохраняется?
		- В таблице процессов
	
	Прерывание таймера приводит к переключению на другой процесс

[00:57:12]  Как можно посмотреть за происходящим?
	
	1. vmstat
		без аргументов выводит одну строчку
		cs - переключение контекста в секунду
[00:58:18]