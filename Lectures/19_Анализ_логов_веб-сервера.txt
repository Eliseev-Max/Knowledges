Анализ логов веб-сервера

Потоки ввода-вывода
	stdin (0, поток ввода) - зарезервирован для чтения команд пользователя или входных данных
	stdout (1, поток вывода) - зарезервирован для вывода данных, как правило текстовых
	stderr (2, поток ошибок) - зарезервирован для вывода диагностических и отладочных сообщений в текстовом виде

Логи
Утилиты для работы с текстом

[0:07:47] Про потоки
	Когда в системе стартует какой-нибудь процесс, ему назначается 3 потока:
	► поток ввода
	◄ поток вывода
	◙ поток ошибок
	
	Процесс = экземпляр программы, которая была запущена
	
	1. Поток ввода (id = 0) необходим, чтобы считывать какие-то входные данные или ввод пользователя
		в саму программу (процесс);
		сам процесс считывает информацию из потока ввода и может использовать её в дальнейшем
	2. Поток вывода (id = 1) необходим для того, чтобы процесс выводил какую-либо информацию
	3. Поток ошибок (id = 2) содержит в основном информацию об exception
	
	<файловые дескрипторы>
	
	Функция Python input() переводит интерпретатор в интерактивный режим. Ожидание ввода
	Ввод пользователя передаётся переменной.
	
	Поток можно перенаправить
	Перенаправление ввода-вывода - возможность командной оболочки перенаправлять стандартные потоки в определённое
	пользователем место
	
	< file - содержимое файла в поток stdin (данные из файла в программу, ожидающую ввода от пользователя)
	> file - поток stdout в новый файл (или перезаписать существующий файл)
	>> file - поток stdout в конец файла
	2> file - поток stderr в новый файл
	2>> file - поток stderr в конец файла
	&>file или >file 2>&1 - объединить stdout и stderr и направить их в файл
	(&> - для более новых версий bash)
		$ ls -l /bin/usr &> ls-output.txt
	&>> - добавить стандартные выходные данные и стандартные потоки ошибок в конец файла
	com1 | com2 - перенаправить stdout com1 в stdin com2
	
		Пример: ls -1 | sort -r (выведет содержимое директории в обратном порядке)
	
	<< - оператор here document; с его помощью можно ввести строковые данные, состоящие из нескольких строк
    	 или присвоить переменной многострочное значение.
		(По умолчанию Enter = разделитель, символ новой строки → не получится ввести многострочное значение, используя Enter.
		<< меняет это правило, обозначением новой строки можно сделать другую последовательность символов
		) Пример:
		cat << _EOF_
		1
		2
		3
		_EOF_
		# Выведет каждую цифру: 1, 2, 3 с новой строки.
# {подробнее: https://zalinux.ru/?p=3934}
		
	
	cat - программа (утилита), позволяющая прочитать содержимое файла прямо в консоли
	head - команда, позволяющая посмотреть первые несколько (по умолчанию 10) строк файла
	less - утилита командной строки, которая отображает содержимое файла или вывод команды по одной странице за раз.
		   ‼ более функциональна, чем more. (подробнее: https://losst.pro/komanda-less-v-linux)
	
	В исполняемых файлах есть маркер EOF, по которому ОС определяет тип файла
	‼ EOF — это не символ!
	! Числовой код EOF равен -1
	‼ EOF (end-of-file) — это состояние, которое может быть обнаружено приложением в ситуации, когда операция чтения файла доходит до его конца.
	В некоторых случаях по содержимому файла ОС может определить его тип и чем с ним взаимодействовать

[0:26:20] Логи. Поиск логов
	Лог - текстовый файл, содержащий информацию о работе системы или приложения
	
	► /var/log - центральное хранилище для всех файловых логов
	► syslog или messages - глобальный системный журнал, в который пишутся сообщения
		с момента запуска системы
	► auth.log - сообщения об авторизации пользователей
	► faillog - сообщения о неудачных попытках авторизации
	► daemon.log - сообщения от различных сервисов (daemons)
	► kern.log - сообщения от ядра (dmesg) <- сообщения от кольцевого буфера, инфо при загрузке ОС
	
[0:31:19] - access.log - файл, использующийся веб-серверами для записи обращений к сайту
	%h %t\"%r\" %>s %b\"%{Referer}i" \"%{User-Agent}i"%D
	
	%h - имя удалённого хоста
	%t - время получения запроса
	%r - тип запроса, его содержимое и версия
	%s - код состояния HTTP
	%b - количество отданных сервером байт
	%{Referer} - URL-источник запроса
	%{User-Agent} - HTTP-заголовок, содержащий информацию о запросе
	%D - длительность запроса в микросекундах
	
	Команда docker, позволяющая попасть внутрь docker-контейнера:
	docker exec -it NAME_OF_CONTAINER /bin/bash		# открыть командный интерпретаторр bash
	
	Посмотреть логи контейнера в docker:
	docker logs -f NAME_OF_CONTAINER	#-f = наблюдать в реальном времени приходящую информацию
	
[0:41:00] - Где искать логи
	* var/log
	* рядом с приложением
	* в специальной системе (Splunk, graylog)
	* команды find / locate для самостоятельного поиска
	* команда lsof для просмотра файлов, открытых процессом
	
	!!! Если результат выполнения скрипта выводится периодически в файл, то необходимо
	после каждого вывода сбрасывать буфер командой		sys.stdout.flush()
	Это предназначено для немедленного вывода на устройство вывода
	
	‼‼ Амперсанд & ставится в конце bash-команды, чтобы запустить процесс в фоновом режиме

	ps aux команда вывода всех процессов
	ps aux | grep NAME.py		Вывести таблицу процессов, содержащих NAME.py
	Находим интересующий нас процесс, копируем его id (process_id)
	и вставляем в команду lsof -p 666		#666 = process_id
	lsof = LiSt of Open Files - утилита, для вывода информации о том, какие файлы используются теми или иными процессами
	►► 7 примеров команды lsof в Linux
		https://andreyex.ru/linux/komandy-linux-i-komandy-shell/7-primerov-komandy-lsof-v-linux/
	
	Убить процесс по id: 	kill -9 666
	
[0:48:55] Что смотреть в логах
	* самые долгие запросы
	* серверные ошибки (5хх)
	* клиентские ошибки (4хх)
	* количество запросов с одинаковыми UA (UserAgent) /IP
	* подозрительные payload		# когда клиент делает POST-запрос со странным содержимым типа кусков кода
	* в логах приложения - exceptions и аномалии в логике
	
[0:53:55]	утилита find
	find - поиск файлов и директорий на основе специальных условий
		-maxdepth - максимальная глубина поиска в поддиректориях
		-type f - искать только файлы
		-type d - искать только директории
		-name - поиск файлов по имени
		-user - поиск файлов по владельцу
		-newer - найти файлы новее, чем указанный
		-size - поиск файлов по размеру
	
	От того, под каким пользователем (root или обычный) мы выполняем find
	Если искать обычным пользователем от корневого каталога (/), можно увидеть ошибки типа
		Permission denied
	Чтобы эти ошибки не загромождали нам экран, можно перенаправить их в отдельный файл ошибок.
	$ find / -name "*.log" 2>/dev/null			# dev/null - это "Чёрная дыра", поглощающая всё, что туда направлено
	
[0:58:35] утилита locate		# Работает быстрее, чем find
	locate - поиск файлов на основе локальной базы данных
		-A - выводит только файлы, соответствующие всем заданным шаблонам
		-d - меняет базу данных для поиска на пользовательскую
		-c - вместо адресов выводит количество найденных файлов
		-i - делает команду нечувствительной к регистру
		updatedb - обновление базы данных для locate
		
	Почему locate быстрее, чем find?
		Потому что поиск происходит по индексу в базе данных, а не проходится по всей файловой системе
	
	alias - ?
	
	Команда file 
	
[1:04:40]  Утилиты для работы с текстом
	cat - просмотр содержимого файла
		-b - нумеровать только непустые строки
		-n - нумеровать все строки
		-E - показывать символ $ в конце каждой строки
		-s - удалять пустые повторяющиеся строки
		-T - отображать табуляции в виде ^|
		-A - показывать все символы
		
	tail - просмотр последних строк файла (по умолчанию - 10 строк)
		-f - обновление вывода по мере появления новых строк в файле
		-F - то же самое, что -f, но в случае, если файла не существует, ожидает его появления
		-n - выводить указанное число строк
		-c - вывести указанное число байт
		-q - не выводить имена файлов
	
	wc -l - (word count) - считает количество строк в выводе
		Пример:	$ tail access.log | wc -l
		
[1:09:49]
	head - просмотр превых строк файла (по умолчанию 10 строк)
		-n - выводить указанное число строк
		-c - вывести указанное число байт
	
[1:10:07]
	grep - поиск в файлах по заданному шаблону
		-c - подсчитать количество вхождений шаблона
		-i - не учитывать регистр
		-r - искать рекурсивно в подразделах
		-n - показывать номер строки в файле
		-v - выдавать все строки кроме тех, что содержат шаблон
		-E - использовать регулярные выражения при поиске
		-An - показывать вхождение и n строк после него
		-Bn - показывать вхождение и n строк до него
		-Cn - показывать вхождение и n строк до и после него
	
[1:15:18]
	sed - потоковый текстовый редактор, применяющий различные текстовые преобразования
		к последовательному потоку текстовых данных
		* меняет данные "на лету"
		* по умолчанию не изменяет файл
		* по умолчанию заменяет только первое вхождение
		* печатает изменения на экран частями, не дожидаясь всех изменений
		
		-e - выполнение последовательности команд
		-f - добавить команды, указанные в файле
		-i - сделать резервную копию файла перед редактированием
[1:16:45] - Примеры
	sed s/"что меняем"/"на что меняем"/ файл_с_которым_работаем - меняет в потоке первое вхождение элемента
	sed s/"что_меняем"/"на_что_меняем"/g файл_с_которым_работаем - меняет в потоке все вхождения элемента
	-e - ключ, позволяющий выполнить последовательность из нескольких команд
	
[1:19:32]  использование Python
	defaultdict()
	Пример:
		dict_ip = defaultdict(
			lambda: {"GET": 0, "POST": 0, "PUT": 0, "DELETE": 0, "HEAD": 0}
		)
	re - модуль для работы с регулярными выражениями
	re.search() - ищет первое вхождение паттерна в строку
	Регулярное выражение для поиска IP-адресов:
	re.search(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", line)
