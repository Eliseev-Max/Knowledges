Построение отчётов с помощью фреймворка Allure

+ Удобная отчётность по тестам для разработчиков, QA и менеджмента
+ прозрачность процесса автоматизации тестирования (повышается понятность, человекочитаемость)

[00:04:00]	Обзор Allure
(http://allure.qatools.ru/ - сайт фреймворка)
	Allure - инструмент для построения понятных отчётов автотестов
	Создание отчёта состоит из двух этапов:
		• во время исполнения теста testing framework adapter собирает данные об исполнении
		  теста и сохраняет их в файлах
		• на основании данных, сохранённых в файлах, происходит генерация HTML-отчёта
		  с помощью command line tool, плагина для CI или build tool

	Thucydides - фреймворк, на базе которого был сделан Allure
		(Allure написан командой разработчиков Yandex)
		• Java-фреймворк (тесты можно писать только на Java)
		• Ориентирован на приёмочное тестирование web-приложений
		• Имеет монолитную архитектуру
	
[00:06:54]	Почему стоит использовать Allure
	
	• прозрачная отчётность не только для разработчиков и QA
	• возможность соотнести автотесты с тест-кейсами
	• понимание, какая именно функциональность покрыта тестами
	• минимум времени на разбор отчёта
	• интеграция с тестовыми фреймворками (pytest, TestNG и т.д.)
	• Поддержка CI (Jenkins, TeamCity)
		CI (Continuous Integration) — в дословном переводе «непрерывная интеграция».
		Имеется в виду интеграция отдельных кусочков кода приложения между собой.
		* это сборка, деплой и тестирование приложения без участия человека *
	
[00:10:40]	Установка Allure

	Allure состоит из двух частей:
		• адаптер				(пакет pip)
		• генератор отчётов		(отдельное ПО для генерации отчётов)
	
	Адаптер - ПО, которое собирает данные о результатах выполнения тестов
	pytest plugin
	$ pip install allure-pytest
	[дополнительно устанавливается пакет allure-python-commons]
	
	Генератор отчётов - ПО, которое на основе данных, собранных адаптером, генерирует Allure-отчёт
	
	Устанавливается
		из пакета:
			$ sudo apt-add-repository ppa:qameta/allure
			$ sudo apt-get update
			$ sudo apt-get install allure
		из архива:
			https://github.com/allure-framework/allure2/releases
			ver. 2.14.0 - latest

[00:13:10]	Процесс генерации отчётов
			

	В файле pytest.ini передаётся дополнительный параметр:
		[pytest]
		addopts = --alluredir allure-results
		
	Он указывает на тот директорий, куда будут сохраняться результаты, собранные адаптером, в формате JSON
	Как этим пользоваться:
		► можно добавить параметр явно в командной строке, в качестве параметра pytest
			pytest test_01_example.py --alluredir allure-results
			# создастся директория allure-results с JSON-файлами в количестве, равном количеству запущенных тестов.
		► чтобы Allure запускался при каждом запуске, нужно прописать эту опцию в файл pytest.ini

[	https://habr.com/ru/post/448796/
	Про pytest.ini
	pytest.ini: Это основной файл конфигурации Pytest, который позволяет вам изменить поведение по умолчанию.
	Параметр addopts добавляет параметры командной строки при запуске фреймворка pytest.
	Пример:
	[pytest]
	addopts = -rsxX -l --tb=short --strict
		Значения ключей:
		-rsxX		- сообщать о причинах всех skipped, xfailed или xpassed тестов;
		-l			- позволит вывести трассировку стека для локальных переменных в случае каждого сбоя;
		--tb=short	- удалит большую часть трассировки стека, оставив файл и номер строки;
		--strict	- запрещает использование маркеров, если они не зарегистрированы в файле конфигурации
	
	Регистрация маркеров в pytest.ini позволяет избежать опечаток и неточностей в именах маркеров:
	[pytest]
	...
	markers = 
	  smoke: Run the smoke test test functions
	  get: Run the test functions that test tasks.get()
	...
	
	pytest --markers	- увидеть зарегистрированные в pytest.ini маркеры
]

		
		https://pytest.org/en/stable/customize.html
		https://pyneng.readthedocs.io/ru/latest/book/additional_info/pytest_pyneng.html
		
	Почему так происходит?
		По умолчанию параметр имеет значение None, поэтому необходимо добавлять
	
[00:16:30]	В JSON-файле содержится следующая информация:
				• "name":				имя теста (название тестовой функции)
				• "status": 			статус прохождения теста (Passed/Failed/Error)
				• "statusDetails":{}	детали, сообщение Exception и trace
				• "description": 		описание тестов (берётся из докстринги теста (""" Docstring """))
				• "start":  "stop":		timestamp, временные метки начала и окончания теста
				• [Идентификаторы]: "uuid", "historyId", "testCaseId"
					На основе "historyId" строятся тренды прохождения теста
				Прочие метки и т.д.
[00:18:44]	Какие опции есть в Allure
	
	allure --help	# Справочная информация
		Команды:
	generate	- Парсит полученные JSON-файлы и на их основе создаёт директорию, выстраивает структуру,
				  необходимую для формирования HTML-отчёта
				  (данные сохраняются локально в папке allure-report)
	serve		- поднимается встроенный веб-сервер для вывода отчёта (== generate + open)
					  данные сохраняются в папке tmp
	open		- открытие отчёта
	plugin		- список плагинов
	
	!!! Пример выполнения команды !!!
	$ allure generate -c && allure open		# опция -c для очистки директории с allure report
	***********************************
	
[00:22:50]	Структура отчётов
	Вкладки в Main Menu (боковом меню):
		Overview - общая информация о тестовом запуске
			SUITES 		- содержимое одного тестового модуля
			ENVIRONMENT - вспомогательный виджет, который можно добавить на страницу Overview,
						  подложив в директорию allure-results файл с описанием выводимой информации [*]
			FEATURES BY STORIES - виджет, связанный с BDD
			EXECUTORS	- машина, на которой выполнялись автотесты (например, Jenkins)
		Categories - категории дефектов тестов (в виде раскрывающихся списков);
					 по умолчанию доступны категории [**]:
						• Product defect (failed tests) [Failed by AssertionError]
						• Test defects (broken tests)
		Suites - стандартная группировка результатов тестов по suites и classes (имеет древовидную структуру)
		Graphs [♦] - статистика, например, диаграмма по статусам тестов, график длительности выполнения тестов и т.д.
					 Особенно наглядна и полезна при работе с Jenkins
				
		Timeline - диаграмма, показывающая распределение тестов в зависимости от длительности выполнения
		Behaviors - группировка результатов по тегам Epic, Feature и Story
		Packages - группировка результатов по package
	
	[**] Категории (Categories) можно пополнять и редактировать, внося изменения в файл categories.json
		Описание категории:
		{
			"name":"Ignored tests",
			"matchedStatuses": ["skipped"]
		}
		Можно добавить следующие опции в описание категории:
			"messageRegex": ".*YourMessage*."		# сообщение, выводимое при возникновении соответствующего Exception
			"traceRegex": ".*FileNotFoundError*."	# поиск Exception по выводимому Traceback
	
	[*]	Файл, описывающий структуру ENVIRONMENT, может быть
		• properties-файлом (environment.properties)
		• xml-файлом
		
		Как выглядит properties-файл:
			Browser=Chrome
			Browser.Version=88.0
			Stand=Production
			
		Расположение environment.properties:		/allure-results/environment.properties
		
		Как собирать информацию о рабочем окружении (environment)
			Автоматическое создание файла:
			► с помощью фикстуры:
			
		@pytest.fixture(scope="session")		# Данная фикстура будет выполнена до запуска всех тестов
		def get_environment(pytestconfig):		# pytestconfig - это фикстура, позволяющая получить доступ к конфигурации запуска pytest
			props = {							# создаём словарь
				'Shell': os.getenv('SHELL'),
				'Terminal': os.getenv('TERM'),
				'Stand': 'Production'
			}
			
			test_root = pytestconfig.rootdir	# rootdir - это корневой каталог allure, из которого производился запуск
			with open(f'{tests_root}/allure-results/environment.properties', 'w') as f:
				for k, v in props.items():
					f.write(f'{k}={v}\n')
		
		Автоматическое формирование файла environment.properties позволяет нам в каждом отчёте иметь актуальную информацию
		по браузеру, в котором запускаются тесты, его версии и типу стенда
		
	[♦]	Виджеты с диаграммами раздела Graphs:
		• STATUS - Кольцевая диаграмма статусов выполненных тестов:
					○ Failed	[произошло исключение AssertionError]
					○ Broken	[в тесте произошло исключение: не AssertionError]
					○ Passed	[тест успешно проёден]
					○ Skipped	[тест пропущен]
					○ Unknown	# не указан status, не распознано Allure
		• SEVERITY 		 - позволяет сразу оценить, какого уровня проблемы есть в билде
						  Каждый тест может помечаться уровнем критичности в зависимости от его важности (веса в проекте)
		• DURATION 		 - Распределение по длительности выполнения тестов (столбчатая диаграмма)
		DURATION TREND 	 - показывает общее время выполнения тестов (линейная диаграмма с площадями под линией до оси)
		RETRIES TREND 	 - тесты, которые в одном запуске работают, а в другом не работают (сколько было retries в данном билде)
		CATEGORIES TREND - распределение по категориям
		TREND 			 - тренд по статусам тестов

[00:38:25]	Вкладка Timeline
	
	Выглядит, как линия времени (горизонтальная, состоит из цветных прямоугольников)
	Можно оценить, какое время выполнялся тот или иной тест.
	Наглядно выглядят тесты, запущенные с использованием pytest xdist.
	
[00:39:19]	Вкладка Packages
	Ещё один вариант группировки тестов.
	
[00:39:48]	Статусы, фикстуры и параметризация
	
	Работа с фикстурами
	scope="session"		фикстура уровня сессии, выполнится до начала выполнения всех тестов
	scope="function"	фикстура уровня функции, выполнится перед тем тестом, в который она включена
	
	После выполнения тестов в отчёте Allure подробную информацию о тестах в тестовом модуле
	можно посмотреть во вкладке SUITES
	(правая область)
	* статус теста ("Passed")
	Overview:				History (для Jenkins = история запуска)			Retries
		• Severity: normal
		• Duration: __s
		[• Parameters]
		Execution:
			Set up:
				<типы фикстур: func, session>
			Test body:
				stdout ►
					описание последовательности выполнения компонентов теста
			Tear down:
				func::0
				session::0

[00:45:55]	Отображение параметров, с которыми был запущен тест
[00:46:57]	Зачем использовать параметризованные фикстуры,
			если есть @pytest.mark.parametrize()
	@pytest.fixture(params=[0,1,...])    vs     @pytest.mark.parametrize("x", [0,1,...])
	1. Параметризованную фикстуру можно сохранить в отдельном файле conftest.py и переиспользовать
	2. Можно указать параметр autouse=True, чтобы фикстура применялась автоматически ко всем тестам
	
[00:52:50]	Titles, descriptions, "очеловечивание" отчёта
	
	@allure.title(str)
	Имя теста можно поменять с помощью декоратора @allure.title("Understandable name of test")
	@allure.title поддерживает вставку аргументов теста и динамическую замену
	
	@allure.description
	С помощью декоратора @allure.description() в тесте можно добавить описание с необходимым уровнем детализации
	@allure.description_html позволяет передать HTML-документ, который будет отображён в секции Description
	
		@allure.description_html(""" HTML-документ """)
		def test_description_from_decorator():
	
	Если в тесте заполнен """docstring""", его содержимое будет отображено в секции Description
	Описание теста может быть динамически изменено с помощью allure.dynamic.description
	( До выполнения - одно описание, после успешного выполнения - другое описание )
	
[01:01:40]	Steps. Использование пошагового представления теста
	
	Allure позволяет настроить детализованное пошаговое представление теста в виде steps
	Декоратор @allure.step добавляет к отчёту вызов декодированного метода или функции с параметрами
	Методы, декодированные @allure.step, могут
		* храниться отдельно от тестов и импортироваться при необходимости;
		* иметь произвольную глубину вложенности
		
[01:02:30]	Примеры (← разобрать)
	@allure.step может быть импортирован из модуля или сразу содержаться в тестовом файле;
	
	@allure.step("Root step")					# Будет отображаться, как Root step
	def step_with_nested_steps():				# Вызов функции nested_step()
		nested_step()
	
	
	@allure.step
	def nested_step():							# Вызов функции nested_step_with_arguments() и передача в неё аргументов
		nested_step_with_arguments(1, 'abc')
	
	
	@allure.step("Nested step with args: {0}, {1}")
	def nested_step_with_arguments(arg1, arg2):
		pass
	
	Можно использовать контекстный менеджер:
		with allure.step(f"Context manager step with arg: {var}"):
			print(var)

[01:07:30]	Метки
	В Allure доступны 3 типа меток:
		• BDD-метки, обозначающие Epics, Features и Stories
		• Severity-метки		# градация важности в метках
		• Custom-метки	
	В pytest можно отмечать группу тестов (например, самые медленные тесты) метками,
	и потом с параметром -m <Название_метки> запускать только эти тесты
	
[01:08:26]	Маркеры BDD
	BDD (Behavior Driven Development) - разработка, отталкивающаяся от поведенческого опыта (от того, как пользователи используют наше ПО)
	Epic может содержать в себе много фичей (Features), т.е.
	за промежуток времени Epic разрабатывается много функционала.
	Features - конкретный функционал, с которым мы имеем дело
	Story - история о том, как пользуются нашим функционалом юзеры.
	Show More → Behaviors
		вложенная сгруппированная структура отчёта, где показываются варианты взаимодействия пользователя с функционалом,
		например:
		* Авторизация:
			► успешная
			► невалидная
	Можно запускать отдельные тесты по заданным меткам
	
	ВСЕ МЕТКИ В pytest МОЖНО ПОСМОТРЕТЬ ТАК:
		pytest --markers
	
	Интеграция с bugtracker-ами или с TMS может осуществляться с помощью:
		@allure.link
		@allure.issue
		@allure.testcase
	Ссылки отображаются в секции Links
	
	@allure.issue в качестве параметра может передаваться ID бага, который затем будет подставлен в соответствующий шаблон ссылки.
	Шаблоны ссылок ► указываются с помощью опции --allure-link-pattern		# в ini-файле
				   ► используют типы issue, link и test_case
	
	Шаблоны и типы ссылок отделяются двоеточием
	$ pytest tests_dir --alluredir=/tmp/my_allure_report \
	--allure-link-pattern=issue:http://www.bugtracker.com/issue/{}

[01:21:30]	Attachments

	отчёты могут отображать различные типы вложений, тем самым дополняя результат test, step или fixture
	Вложения = артефакты тестирования: логи, репорты, скриншоты, JSON-файлы, YAML-файлы, видео MP4 и т.д.
	Вложения могут быть добавлены двумя способами:
		• allure.attach(body, name, attachment_type, extension)
		• allure.attach.file(source, name, attachment_type, extension)
	
	Вложения отображаются в контексте того текста, которому они принадлежат
	HTML-вложения рендерятся и отображаются на странице отчёта

[01:25:35]	Jenkins integration
	Как настроить геенрацию Allure-отчётов в Jenkins?
		1. Установить Allure Plugin [Manage Plugins → Available 'Serch': Allure → Install without Restart]
		2. Выполнить настройку "Allure Commandline" в Global Tool Configuration
			 Name: Allure 2.13.9
			 [v] Install automatically
			 From Maven Central
			 Version		[2.13.9]
		3. В настройках сборки в Post-build Actions добавить Allure Report
		4. В настройках Allure Report указать директорий, в котором хранятся данные,
		   сгенерированные адаптером для используемого тестового фреймворка, например, allure-pytest
		5. После завершения сборки ► посмотреть Allure-отчёт в разделе меню Allure Report
	При очередном запуске Job в Jenkins собирается вся информация о предыдущих запусках.
	На основе предыдущих запусков формируются тренды.
