Оркестрация и взаимодействие контейнеров. Docker Compose

[00:06:41]	Recap (Освежим знания, полученные на предыдущей лекции)

		[Dockerfile] → Build → [Image] → Run → [Container]
		
	docker build [-t, --tag] [-f, --file] context - создание образа
	docker run [--rm] [-it] image				  - создаёт и запускает новый контейнер
	docker stop/kill			  - остановить контейнер (SIGTERM + SIGKILL / SIGKILL)
	
	Базовые команды
	
	docker ps [-a, --all]				- вывести список контейнеров
	docker images						- вывести список образов
	docker exec [-it] <container-id>	- выполнить команду внутри работающего контейнера
	docker rm <container-id>			- удалить контейнер
	docker rmi <image>					- удалить image из системы
	docker inspect [-f, --format] <container-id> - информация о контейнере
	docker inspect --format='{{.Config.Image}}' <container-id>
	
	__Директивы Dockerfile__
	FROM
	RUN
	WORKDIR
	ADD
	COPY
	CMD
	ENTRYPOINT

[00:10:13]	Директива EXPOSE
	
	EXPOSE - сообщает Docker engine о том, что в данном контейнере будет существовать процесс,
			 прослушивающий заданный порт или несколько портов
		Сама директива не несёт непосредственной практической нагрузки (ничего не открывает)
		Директива EXPOSE используется как ДОКУМЕНТАЦИЯ.
		Пользователь будет понимать, что ему нужно будет примапить/открыть порт
		
	При запуске контейнера нужно указать маппинг портов хоста и контейнера
		$ docker run -p {HOST_PORT}:{CONTAINER_PORT} image
		-p = динамический выбор порта
		
[00:21:20]	Manage data
		Работа с данными
	• Bind mounts - данные хранятся в произвольном месте файловой системы
	• Volumes (Тома) - часть файловой системы хоста, управляемой Docker
	• tmpfs mounts - данные хранятся в RAM хоста		# удобно для хранения конфиденциальных данных
(см. рисунок)

[00:24:28]	Bind mounts
	Bind mounts - монтирование локальных директориев / файлов хоста
	docker run -v {HOST_DIR}:{CONTAINER_DIR} <image>
	
	Варианты использования:
		• Шаринг конфигурационных файлов между хостом и контейнером
		• Шаринг исходного кода либо артефактов билдов между хостом и контейнером
		
[00:27:31]	Настройка Bind mounts
		Когда используется Bind mounts, необходимо использовать полный путь, а не относительный
		docker run --rm -it -v /Users/agridyaev/OTUS/docker2/py_server:/app py_server sh
		При выполнении команды попадаем внутрь конейнера, выполняется интерпретатор shell (sh)
		Когда мы создаём Bind mounts для директория, которого нет на хосте, он создаётся
		Bind mounts перекрывает содержимое того, что уже есть в контейнере (содержится в Dockerfile)

[00:33:33]	Volumes
		они более гибкие, чем Bind mounts
	Volumes - механизм для постоянного хранения данных, созданных и используемых контейнерами
	Варианты использования:
		• шаринг данных между несколькими контейнерами
		• когда предполагается удалённое хранение данных контейнера (удалённый хост или облако)
		• когда может потребоваться backup/restore данных контейнера или миграция на другой Docker-хост
	
	docker volume ls		# Посмотреть список volumes в системе
	
	Анонимный Volume (Anonymous volumes)
	
	Создание:
	• Опция -v в docker run 
		docker run -v {CONTAINER_DIR} image
		Пример:
		$ docker run --rm -it -v /app py_server sh		# в системе создаётся volume с ID
														# с флагом --rm контейнер удаляется вместе с volume
	• Директива VOLUME в файле Dockerfile:
		VOLUME/data
	Удаляется при использовании опции --rm вместе с docker run
	
	Backup
		docker run --name py_server -v /py_vol py_srv		# запускаем контейнер, указываем ему анонимный volume
		docker run --rm --volumes-from py_srv -v $(pwd)/backup:/backup ubuntu:20.04		# запускаем промежуточный контейнер
			# команда выше монтирует volume предыдущего контейнера промежуточному конейнеру
		tar cvf /backup/backup.tar /py_vol			# создаём архив
		tar -tvf backup/backup.tar					# разархивирование архива
	
	docker volume inspect <container-id>		# информация о volume
	Удалить неиспользуемые volumes:
	$ docker volume prune
	
[00:47:51]	Именованные volumes (Named volumes)
		гораздо удобнее анонимных volumes
	docker volume create {VOLUME}		# {VOLUME} - задаваемое нами имя
	docker volume inspect {VOLUME}
	docker run -v {VOLUME}:{CONTAINER_DIR} <image>
	docker inspect {CONTAINER} -f '{{(index.Mounts 0).Name}}'		# просто форматирование вывода
	
	Пример:
	$ docker volume create py_vol		# создаём volume
	$ docker run -it -v py_vol:/app py_server sh		# монтируем созданный volume внутрь контейнера
	# запустим ещё один контейнер и пробуем подключить к нему созданный volume
	$ docker run -it -v py_vol:/app another_server sh
	
[00:54:30]	Networking, типы драйверов
	
	Networking-драйверы:
	• bridge - используется для контейнеров, которым нужно сетевое взаимодействие в изолированных сетях 	# default
	• host - для контейнеров с возможностью доступа к сети хоста
	• overlay - для взаимодействия контейнеров на разных хостах
	• macvlan - возможность установки контейнеру MAC-адреса
	• none - для контейнеров без доступа к сети
	
	$ docker network ls
	$ docker network create [-d bridge] <network_name>
	$ docker network inspect <network_name>
	
	Без настройки невозможно обратиться к контейнеру по имени, только по IP
	
[01:05:57]	bridge networks
	
	Особенности default от user-defined bridge network
		• User-defined сети обеспечивают возможность обращения по DNS-имени
		• User-defined сети обеспечивают лучшую изоляцию
		• Контейнеры можно на лету подключать/отключать к/от user-defined сети
	
	Команды:
		docker network connect <network> <container>
		docker network disconnect <network> <container>
		
	Пример:
		# отсоединим контейнер от дефолтной сети
		$ docker network disconnect bridge <container_name>
	
	Если подсеть создана, можно взаимодействовать между конейнерами по их именам (DNS-именам)
	
[01:13:15]	Docker Compose
	
	docker-compose - утилита для создания и запуска многоконтейнерных приложений
	
	Для описания конфигурации используется YAML-формат
	
	docker-compose build - создать многоконтейнерный образ
	docker-compose up (--build) - запустить образ
	docker-compose rm - удалить конейнеры
	
	docker-compose up --abort-on-container-exit && docker-compose rm -fsv
		Опция --abort-on-container-exit следит за работой контейнеров и завершает работу всех контейнеров, когда
		работа хотя бы одного из них завершена.
РАЗЪЯСНЕНИЯ К ДИРЕКТИВАМ DOCKER-COMPOSE ФАЙЛА