Паттерн Page Object

PageObject - Это шаблон проектирования при котором каждая страница (экран) приложения описывается,
			 как объект внутри которого инкапсулируется и реализуется логика действий, которые на этой
			 странице можно выполнять, вместе с его описанием.
Паттерн базируется на понятиях и принципах ООП.

[00:09:48] Зачем это нужно
	* Повышает читаемость кода
	* Увеличивается стабильность кода
	* Снижается количество копипастов
	* Повышается поддерживаемость кода
	* Эффект зависит от масштаба проекта
	
	При работе с формами (полями) для заполнения рекомендуется перед методом .send_keys("any_key")
	производить очистку формы методом .clear()
	Суть в следующем: страница, с которой мы работаем, представляется как объект, а все действия, производимые
	на странице (найти элемент, кликнуть по нему, очистить поле, ввести в поле данные) = методы объекта
[0:22:31]	Добавим конкретики
	Алгоритм преобразования кода в соответствии с паттерном Page Object:
[0:29:12]	1. Выделяем общие действия 
[0:31:28]	2. Выделяем классы страниц
				В Opencart в отдельный класс выведены Alert
				Отдельный метод - авторизация
				Делаем допущение, что у пользователя уже есть аккаунт (логин + пароль)
	Состав директории page_objects:
		elements/
			Alert.py
			UserLoginForm.py
		CartPage.py
		MainPage.py
		ProductPage.py
		UserPage.py
	
	Opencart сделан на компонентном подходе. Есть общие компоненты для нескольких страниц.
	Это алерты, формы авторизации, карточки продуктов и т.д.
	
[0:37:28] - Применение первых действий по преобразованию тестов к паттерну PageObject
			Описание класса MainPage -[0:39:35]
		Хардкодить какие-либо данные - дурной тон.
		Должен быть набор модулей, которые совершают определённые действия "на лету".

[0:48:25] - Методы на странице продукта
			add_to_wish_list(self)
			add_to_cart(self)
			add_to_comparison(self)
[0:52:24]	Class ComparisonPage:
		Почему лучше создать объект (экземпляр класса) и работать с его методами, чем каждый раз
		создавать новый объект со своим классом?
		- Не нужно расходовать лишний раз память и процессорное время для создания объекта.

[1:00:15]	Не осталось вызовов веб-драйвера напрямую.
[1:04:26]	Оптимизация самих PageObject-ов
		Внутри каждого класса страницы добавляем атрибуты в виде кортежа-локатора
		(By.CSS_SELECTOR, "some_selector")
		Атрибуты = элементы HTML-страницы
		Методы = действия над элементами
		
[1:07:50]	Выносим конструктор классов
		Не обязательно создавать абстрактный класс
		Создаём BasePage
		class BasePage:
		
			def __init__(self, browser):
				self.browser = browser
		И все классы страниц наследуются от класса BasePage
		Боремся с копипастом в классах.
		Одинаковые действия (клики. например) переносим в BasePage
		Добавляем protected метод проверки элемента на странице
		
		def _element(self, locator: tuple):
			return self._verify_element_presence(locator)
			
		где _verify_element_presence() - метод, использующий обработку исключения TimeoutException
		при действии WebDriwerWait(self, browser, 5).until(EC.visibility_of_element_located(locator))
		
		_click_element(self, element):
			ActionChains(self.browser).pause(0.5).move_to_element(element).click().perform()
		
[1:22:00]	О библиотеке Python Faker
		Рекомендация добавить send_keys() в BasePage
		
[1:24:41]	Способ не создавать переменную (например, UserPage): Chain call (Последовательный вызов)
		Объект().метод1().метод2().метод3()
		Метод возвращает self = это ссылка на созданный объект (указывает на созданный объект).
		Можно сделать return self у методов def login_page() ... return self
		
[1:36:00]	Селекторы лучше хранить внутри объектов-страниц в кортежах.

[1:39:50]		Другие варианты
		Проблема PageObject: страница взаимодействует сама с собой. Нет наблюдателя.
		Существует паттерн ScreenPlay
		Вводится т.н. "Действующее лицо", которое выполняет последовательно действия.
		Михаил написал свой фреймворк. посмотреть на Ютубе.
		QA Automation meetup at FunCorp