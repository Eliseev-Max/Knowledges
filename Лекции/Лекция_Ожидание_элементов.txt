Ожидания элементов

[0:06:00] Зачем ждать элементы
	
	1. Возможность более гибко работать со сложным поведением элементов на страницах
	2. Не всегда загрузка страницы == элемент на ней появится/исчезнет/изменится
	3. При выполнении AJAX-запросов, манипуляциями JS на странице вообще не происходит обновления страницы
	4. Некоторые условия поведения довольно сложно формулируются (напр, изменение URL, появление текста внутри эл.)
	
[0:07:57] Какие бывают ожидания
	
	Ожидания:
		явные (explicit)
			мы указываем самостоятельно каждый раз, когда хотим указать точное время, за которое что-то
			должно произойти
		неявные (implicit)
			выставляется один раз и потом используется перед выполнением поиска элемента на странице, прежде чем упасть
		собственные
		
	Зачем использовать явные ожидания, если есть неявные?
		Разные элементы могут иметь различное время появления/исчезновения
		Асинхронность работы веб-приложений, асинхронная загрузка
	
[0:19:33] Работа с ожиданиями
	
	За неявные ожидания отвечает implicity_wait(), куда передаётся в секундах значение времени ожидания
	
		browser.implicity_wait(3)
		на каждое действие даётся указанное время (3 секунды)

[0:28:38] Явные ожидания
	Указать время ожидания
	Указать условия ожидания
	
	Потребуется import:
	from selenium.webdriver.support.wait import WebDriverWait
	form selenium.webdriver.support import expected_conditions as EC
	
	За явные ожидания отвечают:
		Класс selenium.webdriver.support.ui.WebDriverWait
		Модуль selenium.webdriver.support.expected_conditions
		
	1. Нужно создать экземпляр класса:
		wait = WebDriverWait(browser, 3, poll_frequency=1)
		# browser - ссылка на сконфигурированный веб-драйвер
		# 3 - время ожидания
		# poll_frequency - частота проверки selenium
		
		У экземпляра класса есть всего 2 атрибута:
		until - ждёт, пока событие внутри не станет True
		until_not - ждёт, пока событие внутри не станет False
		
		# EC.staleness_of - ожидает, пока элемент не перестанет быть прикреплённым к DOM-дереву
		Пример:
		# На практике делают иначе
		browser.get("URL тестируемого ресурса")
		wait.until(EC.title_is("Loaded!")) - ждёт, пока значение title не станет "Loaded!"
			# EC.title_is - проверяет значение
			# EC.title_contains - проверяет вхождение
		
		На практике:
			browser.get("URL тестируемого ресурса")
			WebDriverWait(browser, 3).until(EC.visibility_of_element_located((By.CSS_SELECTOR, "#header")))
			WebDriverWait(browser, 4).until(EC.visibility_of_element_located((By.CSS_SELECTOR, ".box")))
			# visibility_of_element_located - возвращает элемент, как только он становится видим на экране
		Некоторые методы возвращают элемент, а нектотрые - нет.
		Те, которые возвращают элемент, чаще всего сохраняют в ссылке (присваивают значение) для дальнейших действий над ними.
		
		browser.find_element_by_name("some_js_button").click() - для неасинхронных элементов
		
		ВНИМАНИЕ! Так не делаем!
		
		element = browser.find_element_by_name("some_js_button")
		element.click()		# Не нужно создавать переменную на один раз, неэффективно
		
		МОЖНО сохранять в переменную, если в дальнейшем нужно будет проверить именно этот элемент
		
		js_button = WebDriverWait(browser, 3).until(EC.visibility_of_element_located((By.CLASS_NAME, "target")))
		js_button.click()
		WebDriverWait(browser, 2).until(EC.staleness_of(js_button))			# проверяем, что в течение 2 с после нажатия кнопка исчезла
		
		!!! Архитектурный ход Selenium: названия классов написаны с маленькой буквы, а не CamelCase
		
[0:51:21] Комбинирование подходов явных + неявных ожиданий
	Всегда выбирается ожидание по верхней границе. У кого указано большее время, то и применяется.
	
[0:56:00] Как устроены ожидания
	poll_frequency = POL_FREQUENCY		# Это частота проверки selenium

[1:02:45] Метод Call в библиотеке Selenium (expected_conditions.py) = вызов как функция
	Как работает: функция (метод класса) вызывается с периодичностью в poll_frequency
	Если условие не изменилось на True
		или
	Если не кончилось отведдённое на ожидание время
	time.sleep(poll_frequency) -> повторный вызов.
	
	В метод .until() можно передавать ПО ИМЕНИ (БЕЗ скобок) функции, которые возвращают True или False
	
	Есть возможность настроить игнорируемые исключения
	
[1:14:25] Самостоятельно написанный класс
	CTRL + B -► посмотреть модуль
	Метод __call__ должен принимать driver
	
[1:23:05] Обработка исключений
[1:28:27] Обработка исключений применительно к написанию автотестов на Selenium
[1:30:57] Проверку асинхронного элемента с ожиданием нужно проводить по такому принципу:
	1. Перехватываем исключение TimeoutException
	2. Возбуждаем пользовательское исключение (raise AssertionError)
	
	browser.save_screenshot("name_of_screenshot.png") - Сохранить скриншот
	
	