Работа с ОС Linux с помощью Python

Модули стандартной библиотеки Python:
	• subprocess
	• os
	• sys

[00:03:30]	Модуль subprocess
			subprocess предоставляет API для поддержки работы с процессами
	Что можно делать с помощью subprocess:
		• создавать новые процессы
		• получать доступ к STDIN/STDOUT/STDERR процессов
		• получать коды возврата
		
	Интерфейс
		• run
		• call, check_call, check_output
		• Popen			# Объект класса, представляет собой запущенный процесс
						# Более низкоуровневый инструмент работы
	
	subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None,
					capture_output=False, shell=False,..., **other_popen_kwargs)
	subprocess.run - высокоуровневый интерфейс для выполнения процесса с возможностью захвата его вывода
	
	* Запускает команду, указанную в args
	* Ожидает окончания выполнения команды
	* Возвращает экземпляр класса CompletedProcess (результат выполнения процесса)
	
[00:09:40]	Пример
{ЗАПУСК ПРОЦЕССА В ФОНОВОМ РЕЖИМЕ: поставить после команды &}
	
	from subprocess import (
		run, PIPE
	)
	
	def run_example():
		result = run(["ls", "-l"])		# Передаём команду и параметр в виде списка
		print(result)
		print(result.stdout)
		print(result.stderr)
	
	Пояснение: result.stdout = None, result.stderr = None

	pstree -p <PID>	- дерево процессов
	
	lsof -p <PID> - посмотреть, какие ресурсы задействуются процессом (какие файлы процесс открывает)
	
	При запуске скрипта через терминал запускается 2 процесса: родительский (python3) и процесс-потомок (ls -l или sleep)
	# pstree -p 26		# 26 - PID процесса python3
	python3(26)---sleep(27)
	lsof -p 27
	→	Три стандартных потока (0,1,2) связаны с терминалом (консолью). Любые записи будут переданы в sleep
	lsof -p 26
	→ процесс-родитель также связывает свои стандартные потоки (STDIN/STDOUT/STDERR) с терминалом
	
	Как можно получить значения стандартных потоков?
	Поскольку стандартные потоки процесса-потомка и родительского процесса связаны с терминалом, 
	мы (процесс-родитель) не можем получить значения стандартных потоков потомка
	
	def capture_err_and_out():
		result = run(["ls", "-l"], stderr=PIPE, stdout=PIPE)	
		print(result.stdout)									# выведет b''
		print(result.stderr)									# выведет неформатированный результат выполнения команды
		
	STDOUT и STDERR передаются сейчас в pipe (с разными INODE)
	Процесс-потомок передаёт в pipe (FD: 1w, 2w) вывод STDOUT и STDERR,
	а процесс-родитель считывает из pipe (FD: 3r, 5r) данные вывода.
	Процесс-потомок ► Процесс-родитель
	
	Можно заменить stderr=PIPE, stdout=PIPE на параметр capture_output=True

[00:23:42]	Параметр check=True
		Если команда возвращает exit_code = 0, ничего не произойдёт;
		Если код возврата программы = 1, метод run(['command'], check=True) вызовет CalledProcessError
		Можно таким образом ловить исключения в запускаемых процессах.
[00:25:03]	Тайм-аут (timeout)
		Временные рамки, которые считаются допустимыми для выполняемой программы/утилиты
		
[00:26:35]	shell
		Полезно, когда требуется запустить из скрипта Python что-то похожее на команду BASH
	Пример:
		run(["echo", "$HOME"])			# Не развернётся, выведет $HOME
		run(["echo $HOME"], shell=True)	# Развернёт в терминале переменную окружения $HOME [= путь до домашней директории]
										#(аналогично bash-команде echo $HOME)
		run(["echo $HOME | wc -c"], shell=True)		# Используем pipe для перенаправления вывода команды на ввод команде wc -c
	
	Как выполняется команда с параметром shell=True:
	Родительский процесс python3 вызывает процесс командной оболочки shell,
	которая в свою очередь запускает субпроцесс, описанный в скрипте:
	
	python3(42)---sh(43)---sleep(44)
	
[00:31:08]	Older high-level API
	• subprocess.call - возвращает атрибут return_code
		run(...).returncode		# Analog
		
	• subprocess.check_call - если return code не равен 0, бросается исключение CalledProcessError
		(содержит значение return code в атрибуте returncode)
		run(..., check=True)		# Analog
		
	• subprocess.check_output - возвращает output запущенной команды, если return code не равен 0 -
		бросается исключение CalledProcessError
		run(..., check=True, stdout=PIPE).stdout