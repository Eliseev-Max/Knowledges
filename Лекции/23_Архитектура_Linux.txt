
[00:05:20]	Ядро Linux

[
	Ядро - это часть Linux, отвечающая за выполнение простейших функций, таких как
			• управление памятью,
			• доступ к жёстким дискам и сетевым картам
			  и т.д.
	Ядро организовано по модульному принципу: 
		► сначала (при запуске компьютера) загружается основное ядро, содержащее только функции, 
		  которые требуются для старта системы;
		► если в ходе работы понадобятся дополнительные функции (например, для работы с конкретным оборудованием),
		  то необходимый код подключится к ядру как модуль;
		► если в течение некоторого времени эти доп. функции будут не нужны, модуль может быть удалён из ядра.
		
		kmod - компонент, интегрированный в ядро Linux, который отвечает за то, чтобы модули ядра загружались
			   автоматически по мере необходимости
		kmod управляется файлом /etc/modprobe.conf
		
		До версии 2.6.15 ядро и его модули должны были точно подходить друг к другу:
			невозможно было загрузить модуль, скомпилированный для другой версии ядра.
		Для каждой версии ядра создавался отдельный каталог модулей /lib/modules/версия_ядра
		
			* /lib/modules/версия_действующего_ядра - здесь находятся все модули.
			Файлы модулей имеют расширение *.ko
			
		В версии ядра 2.6.16 и выше появилась функция module versioning, позволяющая применять модули 
		и из других версий ядра. Вместе с модулем сохраняется доп. информация, сообщающая, возможно ли
		совместно использовать конкретный модуль и конкретное ядро (разных версий).
		Чтобы этот механизм работал → активизировать функцию module versioning
		
		uname -r	- выводит номер версии используемого ядра
		insmod [параметры] <полное имя файла>	- интегрирует указанный модуль в ядро
		modprobe	более предпочтительная команда для интеграции модулей в ядро
					# сама ищет файл модуля (указываем только название модуля)
					# при необходимости загружает все модули, требуемые для работы
					# учитываются все параметры модуля, указанные в etc/modprobe.conf
		lsmod	- возвращает список ВСЕХ модулей ядра, загруженных в настоящий момент.
		rmmod	- удаляет указанный модуль из ядра (если модуль в данный момент не используется)
		modinfo	- вывод подробной информации о модуле (! модуль не должен находиться в ядре)
]

	В Kernel space разрешён полный доступ к аппаратным средствам (память и устройства ввода-вывода),
	в User space - ограниченный доступ. Программам из User space не разрешён доступ к аппаратным средствам.
	Доступ к компонентам ядра из User space осуществляется посредством System Calls.
	System Calls - специализированные наборы обращений для получения услуг ядра.

[00:07:20]	Принцип работы программ; получение доступа из User space к аппаратным устройствам
			► пользователь запускает скрипт, который что-то записывает в файл
			► скрипт обращается к ядру посредством системного вызова с запросом на запись на HDD
			► ядро обрабатывает вызов и возвращает результат
			
	Команда open() - открывает существующий файл либо создаёт и открывает новый файл
	Как это выглядит с точки зрения вызовов:
	#include <sys/stat.h>
	#include <fcntl.h>
	int open(const char *pathname, int flags);
		*pathname - путь до файла
		flags - параметр доступа к записи (чтение, чтение и запись, запись)
		int - номер файлового дескриптора
		Файловый дескриптор - это идентификатор файла, с которым мы взаимодействуем в рамках нашего скрипта
		С помощью этого идентификатора происходит обращение к файлу
		
	close() - закрывает открытый дескриптор файла, высвобождая его для последующего повторного использования процессом
		#include <unistd.h>
		int close(int fd);
		fd - файловый дескриптор
		
[00:12:02]	Типы ядер
	
1. Монолитное ядро (как у Debian, Ubuntu, FreeBSD)
	В рамках ядра присутствуют компоненты (Kernel functions, Device Drivers)
	Все компоненты выполняются с одинаковыми привелегиями
	+ не происходит смены контекста при работе между компонентами ядра.
	  подсистемы общаются в рамках одного адресного пространства
	- ошибка в каком-либо компоненте может привести к неработоспособности ядра
	
2. Микроядро (QNX, AIX, Minix)
	есть приложения, которые запускаются в User space
	есть набор компонентов (IPC, Memory, Scheduler) работающих в Kernel space
	подсистемы, взаимодействующие с сетью, с диском и устройствами ввода-вывода, вынесены в User space
	Компоненты ядра работают с разными привелегиями:
		планировщик processes/threads и менеджер памяти - максимальные привелегии
		менеджер ввода/вывода, драйверы устройств, файловые системы, сетевые протоколы и пр. - с меньшими привелегиями
	
	Приложение обращается к ядру
	Ядро обрабатывает вызов и передаёт команду компонентам в User space
	Компоненты отправляют ответ (результат) обратно ядру
	Ядро возвращает приложению ответ
	
	- смен контекста больше, чем у монолитного ядра
	- → ниже производительность
   (+) микроядро меньше по кодовой базе
	+ если возникает сбой в работе одного из компонентов, это никак не скажется на работе других компонентов и ядра
	
3. Гибридное ядро (= модифицированные микроядра)
	позволяет для ускорения работы запускать модули ОС в пространстве ядра

[00:20:04]	Файловая подсистема
			FHS (Filesystem Hierarchy Standart) - стандарт, унифицирующий местонахождение файлов и каталогов с общим назначением
			в файловой системе UNIX
	$ man hier
	/bin - системные программы общего назначения (sed, rm, mv...)
	/lib - системные библиотеки
	/etc - общесистемные конфигурационные файлы
	/home - домашние директории пользователей
	/var - хранилище динамических данных
	/proc - псевдофайловая система proc
	
[00:25:57]	Типы файлов

	- 	обычный файл
	d	директорий
	l	символическая ссылка (аналог ярлыка файла в Windows)
	b	блочное устройство (/dev/sda1) [позволяет оперировать с информацией блоками: HDD, CD/DVD-ROM]
	c	символьное устройство (/dev/null, /dev/full, /dev/zero) [оперирует потоком символов (посимвольно): терминал]
	p	(pipe) именованный канал (/dev/initctl)
	s	сокет (/dev/log)
	
	/dev/null	- "чёрная дыра", принимает вывод любой программы и ничего не возвращает
	/dev/full/	- имитация полностью заполненного диска, куда невозможно ничего записать
	/dev/zero	- генерация нулей любого размера (для перезаписи области памяти (напр. диска) нулями)

	ll - алиас для команды ls -lahi
	Команда выводит список файлов с дополнительными данными:
	1 столбец - индексный дескриптор
	2 столбец - права доступа к файлу
	3 столбец - количество ссылок на файл
	4 столбец - имя пользователя-владельца файла
	5 столбец - имя (первичной) группы пользователя 
	6 столбец - размер файла
	7 столбец - время создания файла
	8 столбец - имя файла
	
	Создать символическую ссылку: 	ln -s <имя_файла> <имя_символической_ссылки>
	lsblk		# Какие блочные устройства есть в системе
	
	Именованный канал - компонент для межпроцессного взаимодействия
	Взаимодействие однонаправленное (как, например, у run/initctl)
	ИМЕНОВАННЫЙ КАНАЛ предназначен для взаимодействия неродственных процессов
	НЕИМЕНОВАННЫЙ КАНАЛ предназначен для взаимодействия родственных процессов (родитель - потомок)
	
	Сокет - одно из средств межпроцессного взаимодействия.
	Сокет отличается от именованного канала тем, что он обеспечивает двунаправленное взаимодействие.
	Это такой тип взаимодействия, при котором несколько поставщиков могут взаимодействовать с сервером.
	
	Пример: /dev-log	(run/systemd/journal/dev-log)	-	направляет запросы в централизованную службу журналирования
	
[00:42:58]	Пользователи и группы

	cat /etc/passwd	- получение списка пользователей (пароли /etc/shadow)
	Формат вывода:
	
	[Зарегистрированное_имя]:[пароль]:[ID пользователя]:[ID группы]:[Реальное_имя (GECOS)]:[Домашний каталог]:[Оболочка (командный интерпретатор)]
	
	adduser <USER> - добавление нового пользователя
	deluser <USER> - удаление пользователя
	[Эти команды требуют повышенных привелегий]
	
	cat /etc/group - получение списка групп (пароли /etc/gshadow)
	
	[имя группы]:[Пароль]:[Идентификатор группы (GID)]:[Дополнительные участники группы]
	sudo:x:27:max,agr
	
	addgroup <GROUP> - добавление новой группы
	delgroup <GROUP> - удаление группы
	
	Каждому файлу назначен пользователь-владелец и группа-владелец
	
	r - чтение (просмотр списка имён файлов)
	w - запись (удаление/создание файлов)
	x - исполнение (обращение к файлам по имени)
	
	Структура строки ПРАВА ДОСТУПА ФАЙЛА:
	rwx|rw-|r--| 
	1 группа (rwx): - набор прав для пользователя-владельца файла
	2 группа:	права для пользователей, которые входят в превичную группу пользователя-владельца
	3 группа:	права для всех остальных пользователей
	
	chmod - установка прав на файл/директорий
	chown - смена владельца
	chgrp - смена группы-владельца	
	
	Как происходит смена:
	Есть 4 типа сущностей:
		u - поменять права пользователю-владельцу
		g - поменять права группе
		o - поменять права всем остальным пользователям
		a - поменять права всем
		
	chmod u-w,g+x hello		# убрать пользователю-владельцу право на запись и добавить группе право на исполнение
	
[00:54:34]	Как использовать цифровые значения при назначении прав доступа
			Назначение на какой-либо файл цифровые пермиссии
			Например, 
			chmod 777 hello
			777 - восьмеричное представление	(2^0 + 2^1 + 2^2 = 7)

[00:56:55]	Индексный дескриптор (inode)
			inode - структура данных, в которой хранится метаинформация о стандартных файлах 
			(владелец файла, где расположены блоки файла на диске и т.д.), каталогах или других
			объектах файловой системы, кроме данных и имени
			[имя_файла]	-	[метаинформация о файле]	-	[Данные файла]	# Хранятся в разных местах
			
		$ df -i			# Количество оставшихся файловых дескрипторов
		
		Filesystem		Inodes		IUsed		IFree		IUse%	Mounted	on
		/dev/sda1		456064		45705		410359		11%		/
		/dev/sda6		789968		   39		789929		 1%		/home
		
	$ sudo tune2fs -l /dev		# посмотреть текущее количество inode
	
	$ stat <имя-файла>		# вывод информации о файле
	
	Если кончаются файловые дескрипторы:
		мы не сможем создать новый файл (даже при наличии свободного места на диске)
	
	Индексные дескрипторы создаются, когда монтируется (создаётся) файловая система
	
[01:03:00]	Ссылки

	Жёсткая ссылка
		* inode файла = inode ссылки
		* не может быть создана для файла в другой файловой системе
		* при удалении файла продолжает указывать на блоки данных
		
	$ ln file file_h
	
	Счётчик ссылок хранит информацию о количестве жёстких ссылок
	Размер жёсткой ссылки = размер файла, на который она указывает
	Жёсткая ссылка = аналог файла
	
	Символическая ссылка
		* размер равен количеству байт в пути, который задан при создании ссылки
		* при удалении файла указывает в никуда
		
	$ ln -s file file_s
	
	Размер символической ссылки = размеру пути до файла
	
[01:08:31] Файловые дескрипторы (file descriptor, fd) [НЕ ПУТАТЬ с inode = индексным дескриптором]

	fd - это целое число без знака, с помощью которого процесс обращается к открытому файлу.
		Содержит информацию, описывающую файл, например inode, режим открытия файла и т.д.
		Файловые дескрипторы уникальны в пределах одного процесса
		По умолчанию для процесса создаются 3 файловых дескриптора:
			0 (STDIN) - ассоциируется с ВВОДОМ данных у процесса
			1 (STDOUT) - используется процессом для ВЫВОДА данных
			2 (STDERR) - используется для вывода данных, сообщающих об ОШИБКЕ
	
	Перенаправление потоков:
	./hello.txt > greet		# перенаправить поток вывода из файла hello.txt в файл greet
							# создать файл greet или перезаписать, если файл с таким именем существует
	./hello.txt >> greet	# дозаписать в конец файла greet вывод из файла hello.txt

[01:16:07]	Процессы
	
	Процесс - это программа на стадии выполнения
	fork() - системный вызов, который создаёт новый процесс путём полного копирования существующего
	exit() - системный вызов, который завершает выполнение процесса и освобождает все занятые им ресурсы
	
	PID (process identificator) - положительное целое число, уникальным образом идентифицирующее процесс в системе
	ps - список всех выполняющихся в системе процессов
	
	$ ps u <PID_процесса>
	
	Команда lsof -p <PID_процесса>	 - ресурсы, которые потребляет процесс
	
	/proc - виртуальная файловая система, которая предоставляет программам в виде файлов информацию о процессах,
			тредах и прочих сущностях ядра и используемых ими ресурсах
	Набор каталогов с именами в формате /proc/PID, где PID является идентификатором процесса, позволяет просматривать
	информацию о каждом процессе, запущенном в системе
	
	uptime и /proc/uptime
	
	Межпроцессное взаимодействие - это механизм, который включает в себя взаимодействие одного процесса с другим процессом
	
	Методы межпроцессного взаимодействия:
		• файл				# один процесс пишет в файл информацию, а другой - считывает
		• код возврата
		• сигнал
		• канал (конвейер)
		• неименованный/именованный локальный сокет
		• неименованный/именованный канал
		• разделяемая память
		• семафоры и очереди сообщений
	
	Код возврата - это целочисленное значение, которое дочерний процесс возвращает
				   родительскому процессу в момент завершения
	echo $?		# код возврата последнего выполненного процесса
	exit status = 0 - успешное выполнение команды				# true -> код возврата 0
	exit status > 0 - при выполнении команды произошла ошибка	# false -> код возврата 1
	
[01:28:20]	Сигналы
		
	Сигнал - простейшая форма межпроцессного взаимодействия, предназначен для внешнего управления процессами
	
	kill -l - список всех сигналов
		• SIGINT - сигнал прерывания с терминала Ctrl+C (код 2)
		• SIGQUIT - сигнал "Quit" с терминала Ctrl+\ (код 3)
		• SIGKILL - безусловное завершение (код 9)
		• SIGTERM - сигнал завершения, default для kill (код 15)	[gracefull-завершение]
		• SIGSTOP - остановка выполнения процесса (код 19)
		• SIGTSTP - сигнал остановки с терминала, Ctrl+Z (код 20)
		• SIGCONT - продолжить выполнение остановленного процесса (код 18)
	
	kill -9 <PID> - послать SIGKILL процессу
	kill -SIGINT <PID1> <PID2> - послать SIGINT процессам <PID1> и <PID2>
	
[01:30:35]	Конвейер (pipeline, |)
		- некоторое множество процессов, для которых выполнено следующее условие: то, что выводит на stdout предыдущий
		  процесс, попадает в STDIN следующего процесса
		Запуск конвейера реализован с помощью системного вызова pipe()
		
		$ ls | sort | head -n 2		# ограничить количество выводимой информации (head) до первых 2 строк (-n 2)
		$ ps ax | grep [p]ython
	
[Книги]:
		Д.Кетов "Linux. Внутреннее устройство"
		Б.Уорд "Внутреннее устройство Linux"
		М.Керриск "Linux API. Исчерпывающее руководство"